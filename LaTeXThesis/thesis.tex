\documentclass[11pt,a4paper]{report} 

% Für doppelseitigen Ausdruck (nur bei > 60 Seiten sinnvoll)
% \usepackage{ifthen}
% \setboolean{@twoside}{true}
% \setboolean{@openright}{true} 

\include{preamble} % alle Pakete und Einstellungen

%\bibliography{online}

% Hier anpassen 
\newcommand{\welchethesis}{Bachelor}
% \newcommand{\welchethesis}{Master}
\newcommand{\thesisofwas}{of Science}
\newcommand{\studiengang}{Technische Informatik}
% \newcommand{\studiengang}{Medizintechnik}
\newcommand{\titel}{Entwicklung einer Softwarelösung zur Nutzung von Smartphones als Sensor- und Aktor}
\newcommand{\kurztitel}{Template Abschlussarbeit}
\newcommand{\autor}{Marius Cerwenetz}
\newcommand{\datum}{08. Juli 2022} % Abgabedatum
\newcommand{\ort}{Mannheim}
\newcommand{\referent}{Prof.\ Dr.\ Peter Barth}
\newcommand{\korreferent}{Prof.\ Dr.\ Jens-Matthias Bohli}

\begin{document}
%todo: Rechtschreibprüfung Paula reinbringen
%todo: Jedes Chappter außer Einführung und Fazit benötigen ein Intro.
%todo: kein 'außerdem'

\include{vorspann} % Titelseite, Erklärungen, etc.


\begin{abstract}
%todo: zu kurz
Um Programmieraufgaben interaktiv zu gestalten, eignen sich Projekte mit Mikrocontrollern besonders gut.
Smartphones bieten einen vergleichbaren Sensorumfang und können Ausgaben virtuell darstellen.
In dieser Arbeit wurde eine Softwarelösung namens Smartbit erstellt, um Smartphone-Sensoren über eine Programmierumgebung auszulesen und Ausgaben auf dem Smartphone auszuführen.
Hierfür wurde eine Android-Anwendung, eine Kontrollanwendung und eine programmiersprachenunabhängige Softwarebibliothek erstellt.

Die Benutzung wurde unter Verwendung einer Programmierbeispielaufgabe evaluiert.
Auftretende Latenzen sind vernachlässigbar und die Benutzbarkeit gegeben.
\end{abstract}

\tableofcontents

\chapter{Einführung} \label{chap:intro}
%todo: Irgendwie muss implementierte Lösung = Smartbit-Lösung heißen. Hier introducen.
Viele angehende Programmiererinnen und Programmierer mühen sich beim Programmieren lernen zum Anfang mit der Semantik von Programmiersprachen und grundlegenden algorithmischen Konzepten.
Akademische Übungsaufgaben senken durch rein virtuelle Aufgabenstellungen ohne Interaktionsmöglichkeiten die Lernmotivation.
Aufgaben in Verbindung mit Mikrocontroller-Schaltungen stellen dagegen eine praktische, fordernde und spielerische Einstiegsmöglichkeit dar, um Programmieren zu lernen.
In den Projekten werden kleine Programme realisiert, die durch die Verwendung von Sensoren Programmiererinnen und Programmierer einladen, sich an den Aufgabenstellungen auszuprobieren.
Die in Mikrocontroller-Schaltungen integrierten Sensoren sind Voraussetzung, um physikalische Eigenschaften in der realen Welt zu messen.
Von Programmiererinnen und Programmierern entwickelte Programme können auf dem Mikrocontroller die verbundenen Sensoren auslesen und auf Änderungen der gemessenen Werte reagieren.
Zusammen ermöglichen Sensoren, Mikrocontroller und das entwickelte Programm eine Bedienung der Schaltung.
Während der Entwicklung treten jedoch häufig Probleme auf.
Selten verhält sich das Programm beim ersten Versuch korrekt.
Eine Anpassung des Codes ist nötig, bis das Fehlverhalten beseitigt ist.
Diese kontinuierliche Weiterentwicklung mindert Ängste vor Code-Änderungen, schafft Routine in der Entwicklung und damit ein tieferes Verständnis und Hintergrundwissen für die Problemstellung.
Sinnvoll sind diese Projekt-Eigenschaften insbesondere für Programmiererinnen und Programmierer mit wenig Vorwissen, wie Schüler oder Erstsemester-Studierende.
Praktische Programmieraufgaben bieten für sie den größten Lerneffekt und motivieren am Meisten \cite{learning_computer_programming}.

Mikrocontroller-Projekte benötigen allerdings teure Einstiegs-Kits.
Die Kosten eines Arduino-Development-Boards belaufen sich im Arduino-Shop über 80,00 € \cite{arduino_kit}.
Ein Großteil der Kosten entfällt zwar auf den konkreten Mikrocontroller, ein nicht unerheblicher Teil jedoch auf Peripherie wie wie Breadboards, Verbindungskabel und Erweiterungsboards.
Die Peripherie-Anbindung setzt zusätzliches Hintergrundwissen in elektrotechnischen Bereichen voraus, zum  Beispiel bei den Verschaltungskonventionen von Breadboards oder der Benutzung von Lötkolben.
Fehlerhafte Verdrahtungen oder ein Fehlgebrauch resultieren in zerstörten Komponenten oder Verletzungen.
Dies stellt ebenfalls eine Einstiegshürde dar, die die eigentliche interaktive Lernerfahrung herauszögert und die Motivation senkt.

Smartphones dienen für angehende Programmiererinnen und Programmierer als Alternative zu herkömmlichen Mikrocontroller-Schaltungen für Programmieraufgaben.
Ein Vorteil ihrer Nutzung gegenüber Mikrocontrollern bei Programmierprojekten liegt in der Verfügbarkeit.
2022 besaßen weltweit 5,2 Mrd. Menschen ein Smartphone \cite{smartphone_users}.
Sie sind insbesondere unter Jugendlichen und jungen Erwachsenen weit verbreitet.
Im Alltag wird es für Chats, Social-Media oder Spiele verwendet.
Sie sind also häufig bereits in Gebrauch und müssten für die Nutzung von Programmierprojekten nicht zusätzlich beschafft werden.
Projekte in denen Smartphones statt Mikrocontroller verwendet werden reduzieren das Risiko eines Verdrahtungsfehlers der Schaltung dadurch, dass elektrische Schaltungen bereits intern gefertigt und somit von äußerlicher Fehlverwendung geschützt sind.
Der Sensoren-Umfang ist vergleichbar mit dem von Mikrocontrollern.
In Smartphones sind zahlreiche Sensoren wie Lagesensoren, Gyroskop oder Annäherungssensoren integriert.
Durch diese können sie zuverlässig physikalische Umgebungseigenschaften messen.
Neben kabelgebundenen Übertragungsschnittstellen wie USB oder Lightning besteht auch die Möglichkeit, drahtlose Verbindungsmöglichkeiten wie WLAN oder Bluetooth zu nutzen.
Die Geräte sind zudem batteriebetrieben, was Lösungen ermöglicht, die von einer Spannungsversorgung unabhängig sein können. 
Eine Einbindung von Smartphones in Entwicklungsumgebungen ist in den meisten Fällen jedoch nicht möglich.
Visuelle und haptische Ausgaben auf dem Smartphone erfordern eine mobile Anwendung, da Smartphone-Betriebssysteme keine nativen Ausgabemethoden bieten.

In dieser Arbeit wurde eine Softwarelösung mit dem Namen Smartbit entwickelt.
Sie ermöglicht Smartphones statt Mikrocontroller-Schaltungen für die Entwicklung von interaktiven Projekten zu nutzen. 
Sensoren sollen ausgelesen und Ausgaben auf dem Smartphone ausgelöst werden können.
%check: Wenn sich die Struktur ändert muss das hier angepasst werden.
%todo: gereicht raus. hört sich kacke an.
Für die Verwendung der Smartbit-Lösung werden angehenden Programmiererinnen und Programmierern Beispielaufgaben dargereicht, deren Bewältigung eine Bereitstellung von Benutzungsmöglichkeiten seitens der Smartbit-Lösung erfordert.
Die Aufgaben, sowie aus ihnen ableitbare Anforderungen und Rahmenbedingungen, sind in Kapitel \ref{chap:Experimente} zu aufgeführt.
Die drei Komponenten Smartphone-App, Kontrollanwendung und Programmierumgebung und werden in Kapitel \ref{chap:architektur} vorgestellt.
Damit die Komponenten zusammenarbeiten können müssen sie Nachrichten austauschen.
Die für die Interoperabilität benötigen Nachrichtenformate werden in Kapitel \ref{chap:message_formats} präsentiert.
Einsatzbereiche werden jeweilig erklärt und der Nachrichtenaustausch exemplarisch veranschaulicht.
Kapitel \ref{chap:app} behandelt die Funktionsweise und dem Aufbau der Smartphone-App im Detail.
Der Aufbau und das Verhalten, der zwischen Smartphone-App und Programmierumgebung vermittelnden Kontrollanwendung, wird in Kapitel \ref{chap:server_software} erklärt.
Einbindung, Nutzung und Schnittstellen der Programmierumgebung zur Smartphone-App und dem Kontrollprogramm werden in Kapitel \ref{chap:libs} erklärt.
In Kapitel \ref{chap:eval} wird untersucht, ob die vorgegebenen Anforderungen erfüllt wurden.
Dort wird zudem die Verwendung der Smartbit-Lösung anhand einer Beispielaufgabe vorgestellt.
Bei der Entwicklung aufgetretene Schwierigkeiten sowie mögliche Erweiterungen und Verbesserungen der Smartbit-Lösung werden in Kapitel \ref{chap:fazit} diskutiert.

\chapter{Smartphones als Mikrocontroller-Ersatz für Programmieraufgaben} \label{chap:Experimente}
Smartphones sind in sich geschlossene technische Geräte, die neben vordefinierten Verbindungsschnittstellen wie einem USB- bzw. Lightning-Port, WLAN und Bluetooth keine weiteren Schnittstellen bieten, um externe Hardware und Schaltungen anzuschließen.
Gegenüber Mikrocontroller-Schaltungen bieten sie jedoch einen vergleichbaren Sensorumfang.
Integrierte Lautsprecher können die in einer Mikrocontroller-Schaltung  manuell angeschlossenen Piepser ersetzen.
Zudem müssen Smartphones bei der Ausgabe nicht auf Mehrzweck-Ausgabemöglichkeiten wie LED-Grids zurückgreifen, da zweckgebundene Elemente wie Textfelder, Textausgaben oder Bildausgaben während der App-Entwicklung beliebig platziert werden können.

In diesem Kapitel werden Beispielprogrammieraufgaben dargelegt.
Diese können sowohl mit Mikrocontroller-Schaltungen, als auch mit der in dieser Arbeit implementierten Smartbit-Lösung gelöst werden.
Des Weiteren werden die aus den Beispielprogrammieraufgaben hervorgehenden Anforderungen aufgestellt und erörtert.

\section{Beispielprogrammieraufgaben}\label{sec:activities}
Praxisnahe Programmieraufgaben mit interessanten Aufgabenstellungen motivieren Softwareentwickler.
Die in diesem Abschnitt vorgestellten Beispielaufgaben definieren das von Sensormesswerten abhängige Verhalten interaktiver Programme.
Die Aufgabenstellungen sind in Tabelle \ref{tab:excercises} aufgeführt.
Für jede Aufgabe werden die benötigen Sensortypen und Ausgabeschnittstellen beschrieben.
Leserinnen und Leser werden in der Entscheidungsfindung durch die Angabe eines dreistufigen Schwierigkeitsgrades unterstützt.
Dies soll verhindern, dass sich unerfahrene Programmierer mit komplizierten Aufgaben zu Anfang überfordern.
%todo: + ersetzen mit einfach, mittel, sschwer
\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|c|p{2.3cm}|c|}
      \hline
      \textbf{Name der Aufgabe} & \textbf{Benötigte Sensoren} & \textbf{Verwendete Ausgaben} & \textbf{Schwierigkeitsgrad} \\
      \hline
      Disco & - & LED & Einfach \\
      \hline
      Würfeln & Lagesensor & Textfeld & Einfach \\
      \hline
      Diebstahl-Alarm & Näherungssensor & Textfeld, LED, Vibration & Mittel \\
      \hline
      Klatsch-Zähler & Mikrofon & Textfeld & Mittel \\
      \hline
      Dreh-Zähler & Lagesensor & Textfeld & Schwer \\
      \hline
  \end{tabular}
  \caption{Beispielprogrammieraufgaben}
  \label{tab:excercises}
\end{table}

In der Aufgabe \textit{Disco} soll eine virtuelle LED für eine Zeitdauer von 500 ms grün und anschließend 500ms rot leuchten.
Die Verwendung Sensoren ist in dieser Aufgabe nicht nötig, da die LED-Ausgabe unabhängig von Sensormesswertänderungen ausgeführt wird.
%todo: schwierigkeit kursiv
Aus diesem Grund ist die Aufgabe als Einfach eingestuft.

In der Aufgabe \textit{Würfeln} soll ein Schütteln des Geräts erkannt werden.
Zur Verwendung kommt dabei ein Lagesensor zum Einsatz, welcher Gerätebeschleunigungen messen kann.
Wird ein Schütteln erkannt, soll auf dem PC eine Zufallszahl generiert werden.
Anschließend wird diese auf dem Gerät in einem Textfeld ausgegeben.
%todo: schwierkigkeit kursiv
Der Schwierigkeitsgrad wird ebenfalls auf Einfach eingeschätzt, da die Aufgabe unter Verwendung eines Sensors und einer Ausgabe lösbar ist.

In der Aufgabe \textit{Diebstahl-Alarm} wird unter Verwendung des Näherungssensors das örtliche Umfeld des Geräts auf eine Annäherung kontrolliert.
Wird eine Annäherung festgestellt, wird ein alarmierender Text im Textfeld ausgegeben.
Zusätzlich soll die LED die wie in Aufgabe \textit{Disco} die Farbe wechseln.
Neben den visuellen Ausgaben wird die Vibrationsfunktion als haptisches Feedback benötigt.
Im Falle einer Annäherung soll das Gerät fünf mal vibrieren.
%todo: schwierkigkeit kursiv
Der Schwierigkeitsgrad der Aufgabe ist als Mittel eingestuft, da hier zwischen Alarm- und Normalzustand unterschieden werden muss.
Entfernt sich eine Person, muss der Alarm-Zustand verlassen werden können.
Alle Ausgaben werden auf ihren Initialwert zurückgesetzt.

Bei der Aufgabenstellung \textit{Klatsch-Zähler} muss für einen definierten Zeitraum die Anzahl der Händeklatscher gemessen werden.
Diese Anzahl wird anschließend im Textfeld des Geräts ausgegeben.
Zur Verwendung kommen hierfür das Mikrofon als Ein- und das Textfeld als Ausgabe.
Die Schwierigkeit ist auf \textit{Mittel} angesetzt, da die Messwerte von Händeklatschern unterschiedliche Intensitäten aufweisen.
Um einen Händeklatscher zu identifizieren, ist es nötig Grenzwerte zu ermitteln um sie von normalen Hintergrundgeräuschen abzugrenzen.
Eine Visualisierung der Messdaten kann bei dieser Festlegung helfen.

Bei der Aufgabe \textit{Drehzähler} soll der Programmierer das Device innerhalb eines definierten Zeitraums drehen und anhand der Messdaten die Anzahl der Umdrehungen ermitteln.
Diese Anzahl soll anschließend im Textfeld auf dem Gerät ausgegeben werden.
Zur Verwendung kommen hier ebenfalls der Lagesensor als Sensoreingabe und das Textfeld als Ausgabe.
%todo: schwierkigkeit kursiv
Die Aufgabe ist als Schwer bewertet, da hier Wiederholungen in einer Werteabfolge erkannt werden müssen, welche jedoch wie bei der Aufgabe \textit{Klatsch-Zähler} in ihrer Größe variieren können.
Abhängigkeiten zwischen den Messwertergebnissen erschweren eine Erkennung der Umdrehungen zusätzlich.

\section{Anforderungen der Implementierung}\label{sec:anforderungen}
Aus den Beispielaufgaben leiten sich Anforderungen an die Smartbit-Lösung ab.

Geringe Latenzen sind bei der Sensordatenübermittlung für ein responsives Verhalten von Programmen nötig.
Sie tragen zur Lernerfahrung bei, da sich physikalische Änderungen unmittelbar auf das Verhalten des entwickelten Programms auswirken.
Eine Verkürzung der Latenzen ist von mehreren Faktoren abhängig.

Für die Übermittlung von Sensorwerten müssen diese initial vorliegen.
Sensormessprozesse müssen gestartet und Sensoren ausgelesen werden, was die Latenzzeiten erhöht.
Sensormessungen sollten daher nicht erst nach einer Anfrage oder einem Ereignis, sondern direkt zu Anfang gestartet werden und kontinuierlich messen.
Der Versand der Sensorwerte wird durch den Transportweg zwischen Smartphone und Programmierumgebung und deren lokale Gegebenheiten verzögert.
Smartphones bieten keine kabelgebundenen Netzwerkschnittstellen.
Latenzen können je nach Mobilfunk- bzw WLAN Standard, Umwelteinflüssen und der Geräteanzahl in Funkzellen variieren.
%todo: Abkürzungsverzeichnis muss rein. Waaay too much Abkürzungen.
Für Latenzen dient die Round-Trip-Time (\acrshort{rtt}) als Messgröße.
Sie beschreibt die Zeitdauer der Übermittlung einer Nachricht über Hin- und Rückweg eines Hosts zu einem Anderen.
Präventionsprinzipien wie \acrshort{csmaca} (Carrier Sense Multiple Access/Collision Avoidance) verhindern bei WLAN-Verbindungen Interferenzen, erhöhen allerdings die Latenzen.
Während sie bei Standards wie WLAN 802.11b ca. 10 ms beträgt, kann sie bei \acrshort{umts}-Verbindungen (Universal Mobile Telecommunications System) auf 300 ms bis 400 ms ansteigen \cite{network_latencies} .
Zudem kann sie variieren, was bei einer synchronen Übertragung zu nicht nachvollziehbaren Verzögerungen führt.
Um die Latenz des Transportweges geringer darzustellen, müssen Sensorwerte zwischengespeichert werden, um einen Puffer aufzubauen, auf den in Fällen erhöhter Latenz zugegriffen werden kann.
Eine weitere Latenz-Optimierung ist durch den Einsatz effizienter Protokolle möglich.
Der Verlust weniger Sensorwerte ist für die Funktionsweise des Programms unerheblich.
Verbindungsorientierte Protokolle erhöhen die Menge der zu sendenden Nachrichten pro Sensorwert.
Verbindungslose Protokolle sind deshalb zu bevorzugen.

Die Smartbit-Lösung muss einen benutzerfreundlichen Nutzungszugang für Programmierer und die Anbindung ihrer Programme bieten.
Boilerplate-Code soll reduziert werden, um die Verwendung zu erleichtern.
Die angebotene Funktionalität soll mit möglichst wenig Vorwissen nutzbar sein.
Auf serialisierte Ausgabeformate muss verzichtet werden.
Funktionen müssen Rückgabewerte in Form von primitiven Datentypen zurückgeben.
Für die Bedienung aller Ausgabemöglichkeiten des Smartphones muss die Smartbit-Lösung eine Funktion zur Programmierung bereitstellen.
Das Einbinden in bestehende Entwicklungsumgebungen ist neben der benutzerfreundlichen Schnittstellengestaltung Voraussetzung für die Nutzung.
Die Entwicklungsumgebung Eclipse ist im Labor-Kontext weit verbreitet.
Da es sich um eine plattformunabhängige \acrshort{ide} (Integrated Development Environment) handelt, muss auch die Smartbit-Lösung plattformübergreifend in diese Entwicklungsumgebung integrierbar sein.
Nachrichtenabläufe sollen nachvollziehbar sein um fehlerhafte Konfigurationen rasch zu identifizieren und zu korrigieren.
Hierfür muss es eine Logging-Funktion geben, die den Nachrichtenverlauf aufzeichnet und ausgibt.
Programmierer können anhand der Log-Einträge den Versand nachvollziehen, wodurch Fehler ersichtlich werden.

Neben den netzwerktechnischen und nutzungsbezogenen Anforderungen muss die Smartbit-Lösung auch Ausgabemöglichkeiten über die grafische Benutzeroberfläche einer Smartphone-App bereitstellen.
Teil dieser Oberfläche ist eine farbwechselbare Signal-LED.
Zur Ausgabe von Texten und Zeichen muss ein Textfeld implementiert werden.
Durch zwei Tasten muss der Nutzer zudem mit der Anwendung interagieren können.
Neben den optischen Ausgaben bzw. Bedienelementen muss die Smartphone-App auch haptische Ausgaben wie Vibrationen umsetzen können.
Für die Einstellung von Vibrationsmustern muss eine Vibrationszeitdauer konfigurierbar sein.

\chapter{Architektur der Smartbit-Lösung} \label{chap:architektur}
Die implementierte Smartbit-Lösung besteht aus den drei Komponenten Programmierumgebung, Kontrollprogramm und Android-Anwendung, die zur korrekten Funktionsweise miteinander kommunizieren.
%todo: kurzer absatz was steht in diesem kapitel
Eine Übersicht des Aufbaus ist in Abbildung \ref{fig:design} dargestellt.
\begin{figure}[htbp]
\centering
% \includegraphics[width=.9\textwidth]{zeichnung.eps}
\includegraphics[width=\textwidth]{images/framework.pdf}
\caption{System-Aufbau}
\label{fig:design}
\end{figure}
Um mit dem Smartphone zu interagieren bietet die Programmierumgebung eine programmiersprachenunabhängige Bibliothek mit Schnittstellen in Form von Stub-Funktionen an, die die \acrshort{api} (Application Programming Interface) der Kontrollanwendung nutzen.
Die Bibliothek kann in bestehenden Programmcode zum Zweck der Nutzung eingebunden werden.
Zur Unterstützung der Verständlichkeit für angehende Programmierer wurde bei der Entwicklung der Bibliothek auf die Implementierung von Funktionen mit asynchronen Rückgabewerten, wie beispielsweise Futures, verzichtet.
Die in der Programmiersprache Python implementierte Kontrollanwendung, welche ebenfalls auf dem lokalen PC betrieben wird, dient der Nachrichtenvermittlung zwischen Smartphone-App und Programmierumgebung.
%todo: das hier ist Prozess. Abtrennen?
Führt ein Programmierer einen Funktionsaufruf der Bibliothek aus, übermittelt die Bibliothek diesen per \acrshort{udp} (User Datagram Protocol) dem Kontrollprogramm welches über die weitere Verfahrensweise entscheidet.
Bei einer Ausgabeanfrage wird die Nachricht beispielsweise per \acrshort{mqtt} (Message Queuing Telemetry Transport) an das Smartphone übertragen.
Die Kontrollanwendung speichert zudem Sensormesswerte unpersistent in einem Key-Value-Store um sie zu cachen.
Zum Cachen werden Messwerte in regelmäßigen Abständen von der Smartphone-App an die Kontrollanwendung übermittelt.
Bei Eingang einer Sensorwert-Anfrage der Bibliothek sendet die Kontrollanwendung den zuletzt von der Smartphone-App übermittelten Wert an die Bibliothek zurück.
%todo: wo wird erwähnt in welcher Programmiersprache die App geschrieben ist?

Zur Übermittlung der Nachrichten werden die Protokolle MQTT und UDP eingesetzt.
MQTT ist ein auf einem Observer-Pattern basierendes Client-Server-Protokoll.
Durch einen 2 Byte großen Header und  eine maximale Payload-Größe von 260 MB ist es leichtgewichtig und gleichzeitig flexibel.
Nachrichten werden zur Publizierung auf einem Topic an einen MQTT Broker gesendet.
Dieser leitet sie dann an alle Clients weiter die das Topic abonniert haben.
%todo: MQTT Nutzung wurde vom Prof vorausgesetz reinbringen.
Die UDP-Kommunikation zwischen Bibliothek und Kontrollprogramm auf dem lokalen PC wird über ein Loopback-Interface umgesetzt um die Latenzzeiten zwischen Programmierumgebung und Kontrollprogramm zu minimieren.
Als Nachrichtenformat wird \acrshort{json} (JavaScript Object Notation) verwendet.
Das menschenlesbare, kompakte Nachrichtenformat ist weit verbreitet und wird von vielen Softwarebibliotheken unterstützt.

\chapter{Nachrichtenformate der Komponenten}\label{chap:message_formats}
Ein einheitliches Nachrichtenformat ist Voraussetzung für den Nachrichtenaustausch.
Der ausgearbeitete Nachrichtenstandard definiert die Nachrichten in einem Klartextformat.
Nachrichten-Vorlagen sind in einer Datei gespeichert und werden in der Bibliothek, dem Kontrollprogramm und in der Smartphone-App eingelesen, wodurch Sie in allen Komponenten kongruent vorliegen.
Es gibt unterschiedliche Nachrichtentypen, welche in Tabelle \ref{tab:message_types} aufgeführt sind.
Zur besseren Nachvollziehbarkeit der Kommunikation sind zusätzlich Quelle, Ziel und das verwendete Netzwerkprotokoll angegeben.
Eine Liste der vollständigen Nachrichtentypen, inklusive ihrer Felder, ist im Anhang aufgeführt.
\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|p{30mm}|c|c|}
      \hline
      \textbf{Nachrichtentyp} & \textbf{Quelle} & \textbf{Ziel} & \textbf{Netzwerkprotokoll}\\
      \hline
		sensor\_request & Bibliothek & Kontrollprogramm & UDP\\
       \hline
       sensor\_response & Kontrollprogramm & Bibliothek & UDP\\
       \hline
		update\_request & Smartphone & Kontrollprogramm & MQTT\\
       \hline
		rpc\_request & Bibliothek, Kontrollprogramm & Smartphone & UDP/MQTT\\
       \hline
		rpc\_response & Smartphone, Kontrollprogramm & Bibliothek & UDP/MQTT\\ 
       \hline
  \end{tabular}
  \caption{Nachrichten-Typen}
  \label{tab:message_types}
\end{table}

\textit{Sensor\_request}s kommen bei Sensormesswert-Abfragen zum Einsatz.
%todo: zwischengespeichert hat hört sich kacke an. 
Dieser Nachrichtentyp wird von der Bibliothek an das Kontrollprogramm gesendet, wo die vom Smartphone übermittelten Sensorwerte zwischengespeichert wurden.
Nach Eingang ermittelt das Kontrollprogramm, durch Angabe des gewünschten Sensortyp-Kürzels im Feld \texttt{sensor\_type}, den gespeicherten Sensormesswert.
Sensortyp-Kürzel sind für alle Sensoren definiert und dienen in der Kontrollanwendung als Schlüssel der Adressierung der Messwerte im Key-Value-Speicher.
Die Kürzel sind in Tabelle \ref{tab:sensor_types} aufgelistet. 
\begin{table}[htbp]
  \centering
  \begin{tabular}{|c|c|}
      \hline
      \textbf{TYPE-Kürzel} & \textbf{Beschreibung} \\
      \hline
      accel\_\{x,y,z\} & Lagesensor für die X, Y oder Z-Richtung \\
      \hline
       gyro\_\{x,y,z\} & Gyroskop-Sensor für die X, Y oder Z-Richtung \\
      \hline
      prox & Näherungssensor \\
      \hline
  \end{tabular}
  \caption{Sensor-Kürzel mit Beschreibung}
  \label{tab:sensor_types}
\end{table}
Ist für den Sensortyp ein Sensormesswert im Key-Value-Store vorhanden, wird das Ergebnis in einer \textit{sensor\_response}, im Feld \texttt{sensor\_value}, zurückgesendet.
Die Antwort wird von der Bibliothek angenommen und an die aufrufende Funktion zurückgegeben.
Um stets aktuelle Sensormesswerte zu erhalten, müssen sie vom Smartphone in regelmäßigen Zeitabständen übermittelt werden.
Die Android-App sendet daher in periodischen Abständen Nachrichten des Typs \textit{update\_request} an das Kontrollprogramm.
Übermittelt werden zur Einspeicherung und Zuordnung im Key-Value-Store sowohl der Sensortyp als auch der Sensormesswert.
Der gesamte Ablauf der Sensordatenübertragung ist in Abbildung \ref{fig:message_flow_requests} dargestellt.
\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{images/message_flow_sensor}
\caption{Nachrichtenablauf der Sensordatenübermittlung}
\label{fig:message_flow_requests}
\end{figure}
Aufgeführt sind die drei Komponenten Bibliothek, Kontrollprogramm und Smartphone-App.
Die Bibliothek sendet sensor\_requests per UDP an das Kontrollprogramm.
Dieses antwortet über UDP mit einer sensor\_response.
Währenddessen werden der Kontrollanwendung vom Smartphone fortwährend neue Sensormesswerte durch update\_requests übertragen.

Neben Nachrichten die die Sensordatenübermittlung betreffen, existieren zur Umsetzung von Ausgaben auf der Smartphone-App auch Ausgabe-Nachrichten.
Die app-seitigen Ausgaben sind unterscheidbar in Ausgaben mit und ohne Rückgabewert.
Für erstere gibt es den Nachrichtentyp \textit{rpc\_request}.

\acrshort{rpc} (Remote Procedure Call) und bezeichnet clientseitige Funktionsaufrufe, die auf einem Server ausgeführt werden.
Die Bezeichnung entspricht nicht exakt dem Konzept, da ein Kommunikationspartner, Smartphone-App oder Kontrollanwendung, in diesem Fall die Rolle des Servers einnehmen würde.
Die Voraussetzung einer Client-Server-Anwendung ist durch die beidseitige Nachrichtenübertragung zwischen Smartphone-App und Kontrollanwendung nicht gegeben.
Die Bezeichnung wurde unter dem Fokus auf der entfernten Ausführung einer Funktion gewählt und entspricht eher einer Remote Method Invocation (\acrshort{rmi}).

Der Nachrichtentyp rpc\_request enthält die Felder \texttt{command} und \texttt{value}.
Diese spezifizieren die Ausgabe und falls vorgesehen eine mit der Ausgabe verbundene Größe.
Für die Vibrationsausgabe wären die Inhalte des rpc\_requests für eine Vibration von einer Sekunde beispielsweise \textit{vibrate} und \textit{1000}.
Die Nachricht wird von der Bibliothek per UDP an die Kontrollanwendung und von dort aus per MQTT an das Smartphone gesendet.
Die Smartphone-App nimmt die Anfrage an und führt die Ausgabe aus.
Manche Ausgabe-Anweisungen geben zusätzlich einen Rückgabewert zurück.
Damit dieser vom Smartphone zurück an die Bibliothek gesendet werden kann, gibt es das Nachrichtenformat \textit{rpc\_response}.
Eine Nachricht dieser Nachrichtenart wird erst per MQTT an das Kontrollprogramm und von dort aus per UDP an die Bibliothek gesendet.
Der Nachrichtenablauf wird in Abbildung \ref{fig:message_flow_rpc} dargestellt.
%todo: schreiben antwort ist hier grau gestrichelt dargestellt
\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{images/message_flow_rpc.pdf}
\caption{Nachrichtenablauf der RPC-Anfragen}
\label{fig:message_flow_rpc}
\end{figure}
Aufgeführt sind die drei Komponenten Bibliothek, Kontrollprogramm und Android-App.
Die Bibliothek sendet ein rpc\_request per UDP an das Kontrollprogramm.
Dieses leitet die Nachricht per MQTT weiter an die Smartphone-App, wo das Kommando ausgeführt wird.
Ein eventuell anfallender Rückgabewert wird durch eine rpc\_response vom Smartphone per MQTT zurück an die Kontrollanwendung gesendet, welche die Nachricht dann per UDP weiter an die Bibliothek weiterleitet.


\chapter{Aufbau der Android-Anwendung}\label{chap:app}
Die Android-Anwendung ist eine der drei Bestandteile des Frameworks.
Sie dient dazu Sensormessprozesse zu starten, Sensordaten zu übermitteln und Ausgabe-Kommandos auszuführen.
Für diese bietet sie eine Signal-LED, ein Textfeld und zwei Buttons in einer RootActivity an.
Neben UI-Elementen gibt es zusätzlich noch eine Vibrationsausgabe. 
Die Anwendung initiiert zum Start Sensormessprozesse und sendet unter Verwendung von SensorEventListenern die Sensormessdaten in periodischen Zeitabständen an die Kontrollanwendung.
Verwendete Sensoren sind beispielsweise der Lagesensor oder das Gyroskop des Smartphones.
Die gemessenen Werte werden über einen im Hintergrund ausgeführten MQTT-Service versandt, welcher ebenfalls auf eingehende Nachrichten reagiert, um Ausgaben auf dem Smartphone auszulösen.

\section{Startvorgang}
Ein Ablaufplan des Startvorgangs ist in Abbildung \ref{fig:app_flow} zu sehen.
%Todo: Hier fehlen noch die Schritte der EInbindung und Gedöns das ursprünglich nicht rein solte
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/app_ablauf}
  \caption{Ablaufdiagramm Android-Anwendung}
  \label{fig:app_flow}
\end{figure}
In der RootActivity werden anfänglich alle UI-Elemente zur programmatischen Ansteuerung eingebunden.
Anschließend werden die zwei Konfigurationsdaten config.json und protocol.json eingelesen.
In Ersterer sind grundlegende Konfigurationsparameter wie Hostname und Port des MQTT-Brokers oder der Name des Topics definiert.
In der Datei protocol.json werden neben den Schlüsselwörtern und Abkürzungen für Sensortypen und Ausgabekommandos auch Vorlagen für Nachrichtenformate aufgeführt.

Nach dem Einlesen der Konfigurationen wird der zur Kommunikation verwendete MQTT-Service gestartet und asynchron eingebunden.
Über eine ServiceConnection wird beim erfolgreichen Einbinden über eine Callback-Methode der weitere Ablauf der Anwendung definiert, der erst ausgeführt werden soll, wenn eine MQTT-Verbindung hergestellt ist.
RootActivity und MQTT-Service tauschen jeweils ihre Objekt-Referenzen aus.
Methoden des MQTT-Service rufen zum Zweck der Ausgabe Methoden der RootActivity auf.
SensorEventListener benötigen eine Referenz auf den MQTT-Service, da sie bei Sensorwerten über diesen update\_requests versenden.

Der Nachrichtenempfang im MQTT-Service wird nicht im UI-Thread behandelt.
Dies ist jedoch Voraussetzung um UI-Elemente wie die Signal-LED im Service verändern zu können.
Android unterbindet Änderungen der UI-Elemente wenn der verändernde Thread nicht der UI-Thread ist.
Dieses Problem wird durch die Methode \textit{runOnUiThread} umgangen, welche die Änderung in der Ausführungswarteschlange des UI-Threads einreiht.
Eine Übersicht des Vorgangs in in Abbildung \ref{fig:runOnUiThread} dargestellt.
%todo: check: bild genug beschrieben
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/runOnUiThread.pdf}
  \caption{Ausführung auf dem UI-Thread}
  \label{fig:runOnUiThread}
\end{figure}

Der MQTT-Service baut eine Verbindung zu einem in Datei config.json definierten MQTT-Broker auf und abonniert ein ebenfalls in der Konfigurationsdatei angegebenes Topic.
Ist der MQTT-Service eingebunden sind alle Voraussetzungen für eine Übertragung erfüllt und  Sensormessprozesse können gestartet werden.
Die Funktionsweise der Sensormessung wird in Abbildung \ref{fig:sensor_event_listener} dargestellt.
%todo: still need to describe onSensorChanged
\begin{figure}[htbp]
  \centering
  \includegraphics[width=.8\textwidth]{images/sensor_event_listener}
  \caption{Ablauf SensorEventListener}
  \label{fig:sensor_event_listener}
\end{figure}
SensorEventListener werden, nach Prüfung der Verfügbarkeit der jeweiligen Sensoren, gestartet und zentral in einem \texttt{SmartBitEventListenerContainer} gespeichert.
Diese Klasse beinhaltet SensorEventListener für alle unterstützten Sensoren und dient der Datenhaltung der einzelnen SensorEventListener.
Aufgabe der SensorEventListener ist es, auf Sensorwert-Änderungen zu reagieren und eine entsprechende Callback-Funktion in der die Sensorwerte über den MQTT-Service per update\_requests an die Kontrollanwendung übermittelt werden.
Statische Methoden der Klasse \textit{JSONMessageWrapper} ermöglichen die Erstellung der Nachrichtenformate und setzen das Messergebnis in das korrekte Feld ein.
Die so generierte Nachricht wird anschließend über den gebundenen MQTT-Service an das vorher definierte Topic versendet.

Anschließend ist die Startroutine der Mobilen Anwendung abgeschlossen.
Auf Nachrichten wird nun nur noch im MQTT-Service in einem MessageListener mit entsprechendem Callback reagiert und gegebenenfalls eine Ausgabe ausgeführt.
Die Anwendung ist nun betriebsbereit und sendet update\_requests an die Kontrollanwendung.
Übermittelt werden die Sensordaten an den Broker mit einer \acrshort{qos}-Stufe (Quality of Service) von 0.
Auf dieser Stufe wird der Empfang der Nachricht von den Kommunikationspartnern nicht bestätigt.
Verluste von update\_requests sind unproblematisch, da je nach Taktung der SensorEventListener innerhalb kurzer Zeit neue Sensormesswerte zur Übertragung vorliegen.
Eine exakte Zustellung ist hier nicht notwendig.
Höhere QoS-Stufen würden den Übertragungsprozess verlangsamen und Latenzen erhöhen.

\section{Sensoren}
Smartphones beinhalten Sensoren, die Daten über die Umgebungseigenschaften erfassen.
Dazu zählen beispielsweise Bewegung, Annäherung, aber auch Temperatur oder Luftdruck.
%todo: stimmt nicht. die messen einfach. reagiert wird wo anders.
Ihr Zweck besteht darin, auf Änderungen der Werte zu reagieren.
Für unterschiedliche Aufgaben werden unterschiedliche Sensoren benötigt.
Beispielsweise word für \textit{Diebstahl-Alarm} nur der Näherungssensor verwendet, für \textit{Dreh-Zähler} der Lagesensor.
Für die in dieser Arbeit enthaltenen Übungsaufgaben werden folgende Sensortypen verwendet: Beschleunigungssensor, Gyroskop und Annäherungssensor.

Beschleunigungs- bzw. Lagesensoren messen die Beschleunigung in $m/s^2$ für die drei Bewegungsrichtungen: X-, Y- und Z-Achse in einem festgelegten Zeitraum.
Die Erdbeschleunigung ist auch in diesen Messwerten enthalten.
Diese muss für die bereinigten, realen Werte von den aufgenommenen Werten subtrahiert werden\cite{accel_g}.
% todo: einheiten
Messeinheiten unterscheiden sich je nach Sensor.
Das Gyroskop misst keine Beschleunigung, sondern die aktuelle Geschwindigkeit in $rad/s$ der gleichen Achsen.
Zur Übersicht sind diese in Abbildung \ref{fig:and_axes} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=.7\textwidth]{images/android_axes.png}
  \caption{Android-Koordinatensystem}
  \label{fig:and_axes}
\end{figure}
Die Frequenz, mit der Messwerte erfasst werden kann manuell angegeben werden.
Hierfür stehen vier Stufen zur Auswahl.
\begin{table}[htbp]
  \centering
  \begin{tabular}{|c|p{4cm}|}
      \hline
      \textbf{Bezeichnung} & \textbf{Verzögerung} \\
	  \hline
      SENSOR\_DELAY\_FASTEST & Keine. Verwendet die Frequenz des Sensors.\\
      \hline
      SENSOR\_DELAY\_GAME & 20 ms\\
      \hline
      SENSOR\_DELAY\_UI & 60 ms\\
      \hline
      SENSOR\_DELAY\_NORMAL & 200 ms\\
      \hline
  \end{tabular}
  \caption{Sensor-Taktgeschwindigkeiten\cite{sensor-takt}}
  \label{tab:sensor_speeds}
\end{table}
In der Android-App erfolgen alle Messungen mit SENSOR\_DELAY\_NORMAL.
Die Stufe gilt für Android jedoch nicht als festes Limit, sondern wird eher als Richt-Frequenz behandelt.
Android kann die reale Frequenz auch erhöhen.
Nicht alle Smartphones besitzen alle Sensoren.
Daher wird beim Start überprüft, ob der Sensor auch wirklich vorhanden ist.
Ist er es nicht, wird auch keine Messung gestartet.

\chapter{Aufbau der Kontrollanwendung}\label{chap:server_software}
%todo: se chapter needs some more sciency lingu
Zur Vermittlung zwischen der Smartphone-App und Programmierumgebung dient die Kontrollanwendung.
Die Anwendung vermittelt als Middleware zwischen Anfragen der Programmierumgebung und Anfragen der mobilen Anwendung.
Durch Sie können Ausgaben in der Android-App ausgeführt- und Sensordaten abgefragt werden.
Sie wurde in Python entwickelt und ist aus mehreren Komponenten aufgebaut.
In diesem Kapitel wird der Aufbau der Anwendung anhand ihrer zweckgebundenen Komponenten dargestellt und die Funktionsweise der Bestandteile im Detail an Beispielen erläutert.

Die Kontrollanwendung besteht aus mehreren Thread-Klassen, die beim Start der Anwendung gestartet werden.
Sie ist mit den Klassen DataHandler und MQTTHandlerThread aufgeteilt in einen Daten verwaltenden Bestandteil und eine MQTT-Anbindung.
Zusätzlich dient eine Instanz der Klasse SensorDB als Key-Value-Store um die vom Smartphone übermittelten Sensordaten zwischenzuspeichern.
SensorDB bietet einen threadsicheren Zugriff auf ein intern gespeichertes Python-Dictionary.
Eine Übersicht über die Komponenten der Kontrollanwendung ist in Abbildung \ref{fig:serverUml} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/ServerUml}
  \caption{UML Digaramm Server}
  \label{fig:serverUml}
\end{figure}
Die Komponente DataHandler besteht wiederum aus vier Sub-Komponenten, die ebenfalls als Threads nebenläufig laufen: MqttRequestHandler, UDPRequestHandler, UDPRequestQueueWorker und AnswerQueueWorker.
Ziel der Aufteilung der Arbeitsschritte in Threads ist die Gewährleistung der Verfügbarkeit für beide Kommunikationspartner.
%todo: queue erklären. fifo lifo.
Die Thread-Kommunikation wird durch die threadsichere queues \cite{python_queue} realisiert.
Nachrichten werden von einem Thread in der queue abgelegt und in einem anderen aus der queue entnommen.
Eine durch das polling verursachte hohe CPU-Last kann durch blockierende Operationen beim ablegen und herausnehmen abgewendet werden.

Die Funktionsweise und Zwecke der Subkomponenten von DataHandler werden im Folgenden anhand zweier Beispiele erläutert.
Abbildung \ref{fig:serverMqttReqPath} wird zur Erläuterung für das erste Beispiel diskutiert.
Dargestellt ist der Ablaufplan bei Empfang einer von der mobilen Anwendung an die Kontrollanwendung per MQTT versandten Nachricht.
Dies könnte beispielsweise ein update\_request sein.

%todo: startpunkt fehlt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/MqttRequestServerPath}
  \caption{Ablaufdiagramm MQTT Request}
  \label{fig:serverMqttReqPath}
\end{figure}
Für die MQTT-Verbindung wird die unter OpenSource-Lizenz stehende MQTT-Library Paho \cite{paho} der Eclipse-Foundation verwendet. 
Erreicht eine Nachricht per MQTT die Anwendung, wird Sie vom MQTTHandlerThread entgegengenommen.
Dieser hat sich mit einem MQTT-Broker unter der Hostadresse \textit{pma.inftech.hs-mannheim.de} auf ein in der Datei \textit{config.json} angegebenes Topic verbunden und reagiert mit einer Callback-Methode auf eingehende Nachrichten.
Erreicht eine Nachricht den MQTTHandlerThread, wird die Callback-Funktion ausgelöst und die Payload der Nachricht in eine Queue eingetragen.
Der MqttRequestHandler wartet, bis ein Eintrag in der Queue vorhanden ist, entnimmt gegebenenfalls eine Nachricht und bestimmt den Nachrichtentyp der Anfrage.
Prinzipiell können von der Smartphone-App nur zwei Nachrichtentypen an die Kontrollanwendung versandt werden.
Handelt sich um ein update\_request, also einen neuen Sensorwert, muss dieser in der Datenbank aktualisiert werden.
Handelt es sich hingegen um eine rpc\_response, also um eine Antwort auf eine vorausgegangenes rpc\_request, muss diese Nachricht per UDP an die Bibliothek zurückgesendet werden, wofür Sie in eine andere queue abgelegt wird.
Der AnswerQueueWorker wartet, bis der MqttRequestHandler die Nachricht abgelegt hat und sendet diese dann per UDP über die localhost-Adresse \textit{127.0.0.1} auf dem Port \textit{5005} zurück an die Bibliothek.

Das zweite Beispiel befasst sich mit dem Ablauf eines UDP-Requests, also einer mit UDP versandten Nachricht der Programmierumgebung.
Der Ablauf ist in Abbildung \ref{fig:serverUDPReqPath} dargestellt.
%todo: startpunkt fehlt
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/UDPRequestServerPath}
  \caption{Ablaufdiagramm UDP Request}
  \label{fig:serverUDPReqPath}
\end{figure}
Erreicht eine Nachricht per UDP die Anwendung, wird Sie vom UDPRequestQueueWorker entgegengenommen
Dieser bindet beim Start einen Socket für die localhost-Adresse \textit{127.0.0.1} und den Port \textit{5005}  ein.
Geht auf dem Socket eine Nachricht ein, wird Sie in eine queue abgelegt.
Der UDPRequestHandler entnimmt die Nachricht aus der queue und bestimmt den Typ der Anfrage.
Handelt es sich um eine Nachricht des Types rpc\_request, also einer Ausgabe-Anfrage für das Smartphone muss Sie per MQTT an das Smartphone versandt werden, wofür Sie in eine andere queue eingetragen wird.
Der MQTTHandlerThread entnimmt die Nachricht und sendet sie per MQTT ab.
Ist Nachricht hingegen ein SensorRequest, also die Anfrage eines Sensormesswerts, muss eine Nachricht des Typs sensor\_response erstellt und der ausgelesene Wert eingefügt werden.
Dieser wird unter Verwendung der SensorDB-Klasse ermittelt.
Die erstellte, befüllte Antwort muss anschließend an die Programmierumgebung zurückgesendet werden.
Hierfür wird die Anfrage vom UDPRequestHandler in eine Queue eingetragen, aus der der AnswerQueueWorker Sie wieder entnimmt und Sie an die Programmierumgebung zurücksendet.

Zusammenfassend erfüllen die Komponenten folgende Aufgaben.
Der MQTTHandlerThread nimmt Nachrichten per MQTT an und sendet Sie ab.
Das Gegenstück dazu bilden für UDP-Anfragen der UDPRequestQueueWorker, der Anfragen von der Programmierumgebung annimmt und der AnswerQueueWorker, der Anfragen an diese zurücksendet.
Aufgabe des des MqttRequestHandler ist die Bearbeitung von MQTT Requests.

\chapter{Aufbau der Programmierumgebung}\label{chap:libs}
Die Programmierumgebung ist die Schnittstelle, die die Programmierer für die Interaktion mit dem Smartphone in ihren Programmen verwenden.
Sie besteht aus einer Bibliothek, die Funktionen anbietet mit denen Programmierer Sensorwerte einlesen, oder Ausgaben auf dem Smartphone tätigen können.
Sie können die Funktionen in ihren bestehenden Quellcode einbinden und die Funktionen dort verwenden.
Die Bibliothek ist in den Programmiersprachen C, Java und Python vorhanden, damit sie mit verschiedenen Programmiersprachen genutzt werden kann.
In Java und Python ist sie zudem plattformunabhängig.
Für C gibt es zwei Bibliotheken: Eine für Unix- und eine für Windows-Systeme.
In C ist die Bibliothek prozedural mit statischen Methoden, in Java und Python objektorientiert implementiert.

Werden die bereitgestellten Funktionen aufgerufen, werden standardisierte Anfragen im JSON-Format generiert und an die Kontrollanwendung gesendet.
Diese sendet die Daten gegebenenfalls an das Smartphone weiter oder antwortet direkt.
Eine Übersicht ist in Abbildung \ref{fig:Schnittstelle Bibliothek} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=.8\textwidth]{images/lib_server_connection}
  \caption{Schnittstellen der Bibliothek}
  \label{fig:Schnittstelle Bibliothek}
\end{figure}

Alle Anfragen werden über das UDP-Protokoll unter IPv4 versendet.
Das Kontrollprogramm ist auf dem Port 5006 erreichbar, Bibliotheken auf dem Port 5005.
Beide kommunizieren über die localhost-Adresse 127.0.0.1.
Dadurch werden Datagramme über das Loopback-Interface gesendet.
Das Loopback-Interface ist eine virtuelle Netzwerk-Schnittstelle des Betriebssystems eines PCs.
Pakete werden nicht über externe Netzwerk-Schnittstellen wie Netzwerkkarten versendet, sondern verbleiben im Netzwerk-Stack des Betriebssystems.
Die Latenzen sind dadurch mit weniger als 1 ms zur Verwendung der Smartbit-Lösung gering genug.
Zum Senden und Empfangen von Anfragen werden Sockets verwendet.
Für das Empfangen von Paketen müssen diese gebunden werden, für Sendevorgänge nicht.

Bei der Erstellung eines Phone-Objekts in Python und Java werden die Nachrichtenvorlagen für Anfragen und Antworten aus der Datei \texttt{protocol.json} geladen.
Die Datei muss sich im Dateisystem im gleichen Ordner befinden wie die Bibliothek.
Für die C-Bibliothek sind alle Methoden statisch definiert.
Es gibt somit keinen Startpunkt, zu dem die Datei \texttt{protocol.json} eingelesen werden kann.
Damit die Datei nicht für jeden Funktionsaufruf kontinuierlich eingelesen werden muss, muss Sie vom Programmierer einmal zum Start des Programms als cstring eingelesen werden.
Anschließend muss dieser C String für jeden Aufruf einer Funktion der Bibliothek als Parameter angegeben werden.
Die Methode \texttt{get\_file\_content} kann, unter der Angabe des Dateipfades der \texttt{protocol.json}-Datei, aufgerufen werden, um den Dateiinhalt einzulesen.
Zurückgegeben wird der Inhalt als C String.
Diese Lösung verringert die Anzahl der Lesevorgänge und die damit verbundenen durch IO verursachten Latenzen.
Der Inhalt ist ab dem Einlesezeitpunkt auf dem Heap des Arbeitsspeichers gespeichert.
Der Programmierer muss diesen am Ende seines Programms durch den Aufruf der \texttt{free}-Funktion wieder freigeben.
%todo: klingt whack.
Die Ausgabe erscheint als direkter Grund der Annäherung.

%todo: Kapitel JSON Parser.


\chapter{Evaluation der Smartbit-Lösung}\label{chap:eval}
%todo: auch gerne nochmal sprachlich drübergehen.
%todo: Intro fehlt. Worum geht's im Chapter? Qualitative und quantitative Bewertung.
Die Umsetzung der an die implementierte Anwendung gestellten Anforderungen wird in diesem Kapitel überprüft.
Durch Betrachtung eines Verwendungsbeispiels werden die Anforderungen qualitativ untersucht.
Geringen Latenzzeiten wurden in der Konzeptionsphase eine hohe Priorität zugeordnet.
Diese werden anhand der Smartbit-Lösung für drei Nutzungsszenarien gemessen und bewertet.


\section{Verwendungsbeispiel}
Die Verwendung der Smartbit-Lösung wird anhand der Beispielaufgabe \textit{Alarmanlage} vorgestellt.
Gezeigt wird wie die Aufgabe in der Programmierumgebung unter Verwendung der Python-Bibliothek gelöst wurde und wie sich Ausgaben auf dem Smartphone äußern.

Eine gestartete Kontrollanwendung ist Voraussetzung für einen Nachrichtenaustausch.
Mit dem Befehl \texttt{python ./server.py} wird sie in einer Shell gestartet.
Der Vorgang wird in Abbildung \ref{fig:start_controll_app} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=.8\textwidth]{images/server_logging}
  \caption{Start der Kontrollanwendung}
  \label{fig:start_controll_app}
\end{figure}
Die Anwendung meldet eine erfolgreiche Verbindung mit dem MQTT-Broker und gibt das abonnierte Topic aus.
Neben diesen Start-Informationen werden auch eingehende rpc\_requests und rpc\_responses ausgegeben.
Sensor\_requests, sensor\_responses und update\_requests werden wegen ihrer Häufigkeit nicht geloggt.

Die Implementierung der Lösung der Aufgabe ist in Listing \ref{lis:alarm} dargestellt.
\lstset{language=python, captionpos=b, frame=single, numberstyle=\tiny, style=customcs}
\lstinputlisting[label=lis:alarm, caption=Alarmanlage-Beispiel]{listings/code_examples/alarm.py}
Die Bibliothek wird in Zeile 2 in das vom Programmierer geschriebene Programm importiert, wofür sich die Datei \texttt{smartbit.py} und das entwickelte Programm im gleichen Ordner befinden müssen.
In Zeile 4 wird ein Phone-Objekt erstellt, über welches Sensor-Auslesemethoden wie \texttt{get\_x\_accel()} oder Smartphone-Ausgaben wie \texttt{vibrate()} aufgerufen werden können.
Das Programm soll nur im Falle eines KeyboardInterrupts angehalten werden.
In einer Endlosschleife wird der Näherungssensorwert kontinuierlich abgefragt.
Außerdem wird der Ablauf für 500 ms pausiert um einer Nachrichtenflut und somit einer Nichtverfügbarkeit der Kontrollanwendung vorzubeugen.
Der Annäherungssensor sendet im Falle einer Annäherung den Wert 0.0 zurück auf den in Zeile 8 reagiert wird.
Ist die Bedingung erfüllt, wird mit der Methode \texttt{write\_text()} der Text \textit{ALARM} ausgegeben.
Die Methode \textit{vibrate} lässt das Smartphone für die Dauer von 1000 ms vibrieren.
Zum Schluss wird mit der Methode \textit{toggle\_led} noch der Farbwert der Signal-LED von grün auf rot geändert.

Die Bibliothek übermittelt für jede Ausgabe korrespondierende rpc\_requests über die Kontrollanwendung an das Smartphone.
Bei Empfang werden die Anfragen in der Kontrollanwendung geloggt.
Eine Übersicht der gesendeten Nachrichten des Beispiels ist in Abbildung \ref{fig:req_controll_app} aufgeführt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/server_requests}
  \caption{Nachrichtenversand der Kontrollanwendung}
  \label{fig:req_controll_app}
\end{figure}
Zu erkennen sind die unterschiedlichen Ausgabekürzel der Anfragen, welche im Feld \texttt{command} abgebildet sind.
Für die Textausgabe entspricht das Kürzel \texttt{write\_text}, für Vibrationen \texttt{vibrate} und für das Umschalten der LED-Farbe \texttt{led\_toggle}.
Pro Ausgabe-Kommando kann zusätzlich ein Parameterwert angegeben werden.
Für \texttt{write\_text} bestimmt er den anzuzeigenden Text und für \texttt{vibrate} die Vibrationsdauer in Millisekunden.
Da es nicht vorgesehen ist die Farbe der Signal-LED manuell festzulegen, wird für \texttt{led\_toggle} kein Parameterwert angegeben.

Wird die App auf dem Smartphone gestartet, befindet Sie sich im Initialmodus in dem Sie bereits Sensorwerte misst und an die Kontrollanwendung sendet.
Das Userinterface ist in Abbildung \ref{fig:initial_app} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[height=0.4\textheight]{images/app_initial}
  \caption{Initialzustand der mobilen Anwendung}
  \label{fig:initial_app}
\end{figure}
Es besteht aus zwei mit A und B beschrifteten Buttons, einem Textfeld in der Mitte, einer Signal-LED welche zu Beginn grün leuchtet und einer Vorgangs-LED, welche während der Ausführung von Ausgaben aufleuchtet.

Im Alarmfall werden die vom Programm gesendeten Ausgaben entsprechend umgesetzt und das Aussehen des Userinterfaces verändert.
Das Resultat ist in Abbildung \ref{fig:app_alarm} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[height=0.4\textheight]{images/app_alarm}
  \caption{Alarmzustand der mobilen Anwendung}
  \label{fig:app_alarm}
\end{figure}
Das Textfeld stellt nun den Text \textit{ALARM} dar und die Farbe der Signal-LED hat sich von grün auf rot geändert.
Die Vorgangs-LED leuchtet rot um zu signalisieren dass gerade eine Ausgabe ausgeführt wird.
Diese ist nicht sichtbar, denn es handelt sich um das haptische Vibrationsfeedback.

%todo: absatz waaaaaaaaaaaay to short
Die Reaktionszeit liegt unter einer Sekunde.
%todo: hier noch dicke fette qualitative Bewertung der Anforderung.

Latenzprobleme per MQTT treten nicht auf.
Trotz einem QOS-Level 0 werden auch Ausgabeanfragen sicher übertragen und ausgeführt.
Da die Nachrichten über TLS übertragen werden, ist der Austausch sicher.
Logging-Möglichkeiten in der Kontrollanwendung und der Android-App erleichterten die Entwicklung sehr und halfen bei der Fehlersuche.


\section{Latenzmessung}
%todo: introsatz fehlt. liest sich unrund.
Im Zuge der Konzeption wurden Latenzen eine besondere Bedeutung zugemessen.
Erhöhte Latenzzeiten führen zu einem verzögerten Verhalten und einer schlechteren Benutzbarkeit.
Zum Zwecke der Evaluation der Latenzen werden für drei Nutzungsszenarien Messungen durchgeführt.
Da sensor\_requests lediglich über die Local-Loopback-Schnittstelle zwischen Bibliothek und Kontrollanwendung ausgetauscht werden ist anzunehmen, dass diese Verbindung in der Smartbit-Lösung keine Limitierung darstellt.
Auf die Untersuchung der Latenzzeiten zwischen dem Absenden eines sensor\_requests und dem Erhalt einer sensor\_response wird daher verzichtet.

Unbekannt ist indes die Latenz zwischen Smartphone-App und Kontrollprogramm.
Über diesen Transportweg werden die Nachrichtenformate rpc\_request, rpc\_response und update\_request übermittelt.
Durch die marginale Latenz zwischen Kontrollanwendung und Bibliothek können Sensorwerte zwar häufig abgefragt werden, jedoch wird bis zum Eintreffen eines neuen Sensormesswerts der zuletzt Eingespeicherte zurückgegeben.
Sensordatenabfragen sind daher abhängig von der MQTT-Verbindung zwischen Smartphone und Kontrollanwendung.
Um ein realistisches Nutzungsverhalten zu simulieren, wird für die Messungen der Transportweg zwischen Bibliothek und Smartphone-App betrachtet.
Gemessen wird die Zeitdauer nach Versand eines rpc\_requests bis zum Erhalt einer rpc\_response von der Smartphone-App.
Die Smartphone-App sendet währenddessen fortlaufend update\_requests per MQTT umd reguläre Last auf der Kontrollanwendung zu simulieren.
Messungen finden für drei verschiedene Nutzungsszenarien statt: Der Verwendung im Labor des SWT-Instituts an der Hochschule, der Heimarbeit über eine DSL-Verbindung und der Verwendung in einer virtuellen Umgebung.
Für alle Messungen erfolgen Internetzugriffe seitens des lokalen PCs kabelgebunden und seitens des Smartphones über WLAN.
Die Anzahl der verbunden Geräte des AccessPoints sind für die Übertragungszeit ebenfalls ausschlaggebend.
Die bei CSMA/CA zum Kollisionsschutz verwendeten randomisierten Sendefenster limitieren mit steigender Geräteanzahl die Sendezeit und erhöhen die Latenzen.
Um signifikante Ergebnisse zu diskutieren werden pro Nutzungsszenario 100 Messwerte erhoben und in einem Boxplot dargestellt.

Mit dem SWT-Labor befindet sich der lokale PC im ersten Nutzungsszenario im gleichen Netzbereich wie der MQTT-Broker, was den Transportweg reduziert.
Die Messergebnisse sind in Abbildung \ref{fig:measure_institute} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth]{images/timing_institute.pdf}
  \caption{Messergnisse der Latenzmessungen im Heimnetz}
  \label{fig:measure_institute}
\end{figure}
Die Latenzen sind mit Maximalwerten von 138 ms sehr gering  
SensorEventListener erheben Daten mit einer eine Verzögerung von maximal 200 ms.
Hier könnte auch die eigentliche Sensormessung auf dem Smartphone die Übertragungsgeschwindigkeit begrenzen.
Im Labor-Szenario kann die Smartbit-Lösung eingesetzt werden.

Die Messung des zweiten Szenarios erfolgt aus einem Heimnetz mit acht Hops zwischen Broker und lokalem PC. 
Auf dem Access Point sind zur Zeit der Messung acht Geräte registriert.
Die Messergebnisse sind relevant für die Heimarbeit oder für die Verwendung beim Erledigen von Hausaufgaben.
Die Ergebnisse sind in Abbildung \ref{fig:measure_home} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth]{images/timing_at_home}
  \caption{Messergebnisse der Latenzmessungen im Heimnetz}
  \label{fig:measure_home}
\end{figure}
Die Messwerte fallen mit einem Median von etwa 175 ms deutlich höher als im Labor aus, befinden sich allerdings immer noch im tolerablen Bereich und stellen keine gravierende Beeinträchtigung in der Benutzung der Smartbit-Lösung dar.

Im dritten Szenario wird die Messung von einer in VirtualBox gestarteten, virtuellen Maschine auf dem lokalen PC aus gestartet.
Sowohl Bibliothek und Kontrollanwendung werden in der virtuellen Maschine betrieben.
Relevant ist das Szenario ebenfalls für die Heimarbeit.
Es bildet die Verwendung der virtuellen Maschine zum Programmieren ab.
In den Lehrveranstaltungen des Instituts wird dies häufig angewandt um Studierenden auf simplem Wege eine vollständige Programmierumgebung zur Verfügung zu stellen. 
Untersucht wird, ob die Latenzzeiten sich durch die NAT-Funktionalität von VirtualBox signifikant vergrößern.
Die Messergebnisse sind in Abbildung \ref{fig:measure_vm} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{images/timing_vm}
  \caption{Messergebnisse der Latenzmessungen im Heimnetz}
  \label{fig:measure_vm}
\end{figure}
Die Latenzzeiten sind im Vergleich zur Messung auf dem Host-PC nicht wesentlich angestiegen.
Dadurch ist ebenfalls von keiner maßgeblichen Beeinträchtigung der Nutzung auszugehen.
Sie kann auch in virtuellen Entwicklungsumgebungen verwendet werden.

\chapter{Fazit}\label{chap:fazit}
Die Smartbit-Lösung erfüllt die Anforderungen zufriedenstellend.
Die im Vorfeld durchgeführte Konzeption ermöglichte eine problemlose Implementierung.
Während der Entwicklung wurden jedoch einige Designentscheidungen getroffen, welche die Smartbit-Lösung beschränken.
Sensordaten werden von der Kontrollanwendung nicht für einzelne Geräte eingespeichert.
Es ist nicht möglich, Programmcode simultan auf mehreren Smartphones gleichzeitig auszuführen.
Gruppen-Sessions können nicht erstellt werden.
Für Programme die die Java und Python-Schnittstelle erscheint dies kontraintuitiv.
Die Bedeutung eines Phone-Objektes lässt auf eine zwischen Einzelgeräten unterscheidende Verwendung schließen.
Ein weiterer Nachteil der Benutzerfreundlichkeit besteht in der zwingenden Verwendung von Hilfs-Bibliotheken für den Nachrichtenaustausch über JSON.
Sowohl für Java, als auch für C sind zusätzliche JSON-Parser für die Kommunikation zwischen Bibliothek und Kontrollanwendung nötig.
Für eine erfolgreiche Kompilierung in C muss der Dateipfad für diesen dem Linker bekannt gemacht werden.
Für die interne Struktur ist die Datenverwaltung innerhalb des Programms ausreichend.
Durch den asynchronen Ansatz des Multithreading können beide Kommunikationspartner gleichzeitig über das Kontrollprogramm kommunizieren und zwischengespeicherte Daten auslesen oder bearbeiten.
Die Möglichkeit, mehrere Werte zum internen Datenspeicher hinzuzufügen, wird jedoch nicht unterstützt.
Häufige Sensor-Anfragen werden mit dem gleichen, einzeln zwischengespeicherten Sensorwert beantwortet, welcher zusätzlich kein Ablaufdatum besitzt.
Abbrüche der Übertragung resultieren in der kontinuierlichen Übermittlung des zuletzt eingespeicherten Sensorwerts.

Zur Ablösung von Hilfsbibliotheken eignet sich die Verwendung eines Binärprotokolls.
In Enumerationen konvertierte Nachrichtenformate und Parameter könnten statt der implementierten Darstellung mit JSON eingesetzt werden.
Dadurch entfiele nicht nur der Nachteil der kontraintuitiv Einbindung.
Die Nachrichtengröße würde ebenfalls verringert werden.
Energieeffizienz der Android-App wurde zum Vorteil der Latenzreduzierung während der Implementierung nicht wesentlich berücksichtigt.
Zum Start der Anwendung werden die Sensormessprozesse unmittelbar gestartet und Sensorwerte an die Kontrollanwendung gesendet, was einen erhöhten Energieverbrauch bedeutet.
Sollten sich die Startzeiten der Sensormessprozesse nicht wesentlich auf die Latenzen auswirken, wäre eine auf Anfragen basierende Sensormessdatenübertragung erwägenswert, um den Energieverbrauch zu reduzieren.

% Listen wenn überhaupt ans Ende und nicht an den Anfang.
% Meist ist das aber unnötig.
% List of abbrev
\listoffigures % Liste der Abbildungen 
\listoftables % Liste der Tabellen
%todo: glassar ohne index
\printglossary[type=\acronymtype, title={Abkürzungsverzeichnis}, nonumberlist=true]

\newpage

%check: hat das hier geklappt?


\bibliographystyle{plain} % Literaturverzeichnis
\begin{btSect}{thesis} % mit bibtopic Quellen trennen
\addcontentsline{toc}{chapter}{Literaturverzeichnis und Online-Quellen}
\section*{Literaturverzeichnis}
\btPrintCited
\end{btSect}
\begin{btSect}{online}
\section*{Online-Quellen}
\btPrintCited
%\bibliography{online}
\end{btSect}
% dann mit "bibtex thesis1" und "bibtex thesis2" arbeiten

\appendix
\chapter{Nachrichtenformate}
\lstset{language=python, captionpos=b, frame=single, numberstyle=\tiny, style=customcs}
\lstinputlisting[caption=Update-Request]{listings/messages/update_request.json}
\lstinputlisting[caption=Sensor-Request]{listings/messages/sensor_request.json}
\lstinputlisting[caption=Sensor-Response]{listings/messages/sensor_response.json}
\lstinputlisting[caption=RPC-Request]{listings/messages/sensor_request.json}
\lstinputlisting[caption=RPC-Response]{listings/messages/sensor_response.json}


\end{document}
;;; Local Variables:
;;; ispell-local-dictionary: "de_DE-neu"
;;; End:


