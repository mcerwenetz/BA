\documentclass[11pt,a4paper]{report} 

% Für doppelseitigen Ausdruck (nur bei > 60 Seiten sinnvoll)
% \usepackage{ifthen}
% \setboolean{@twoside}{true}
% \setboolean{@openright}{true} 

\include{preamble} % alle Pakete und Einstellungen

%\bibliography{online}

% Hier anpassen 
\newcommand{\welchethesis}{Bachelor}
% \newcommand{\welchethesis}{Master}
\newcommand{\thesisofwas}{of Science}
\newcommand{\studiengang}{Technische Informatik}
% \newcommand{\studiengang}{Medizintechnik}
\newcommand{\titel}{Entwicklung einer Softwarelösung zur Nutzung von Smartphones als Sensor- und Aktor}
\newcommand{\kurztitel}{Template Abschlussarbeit}
\newcommand{\autor}{Marius Cerwenetz}
\newcommand{\datum}{08. Juli 2022} % Abgabedatum
\newcommand{\ort}{Mannheim}
\newcommand{\referent}{Prof.\ Dr.\ Peter Barth}
\newcommand{\korreferent}{Prof.\ Dr.\ Jens-Matthias Bohli}

\begin{document}
\include{vorspann} % Titelseite, Erklärungen, etc.

\begin{abstract}
Um Programmieraufgaben interaktiv zu gestalten eignen sich Projekte mit Microcontrollern besonders gut.
Smartphones bieten einen vergleichbaren Funktionsumfang und müssen meist nicht zusätzlich beschafft werden.
In dieser Arbeit wurde eine Softwarelösung erstellt, um Smartphonesensoren über eine Programmierumgebung auszulesen und Ausgaben auf dem Smartphone auszuführen.
Hierfür wurde eine Android-Anwendung, eine Kontrollanwendung und eine programiersprachenunabhängige Softwarebibliothek erstellt.

Für die Nutzung der Lösung werden Beispiel-Programmieraufgaben dazugereicht.
Programmierer schreiben Programme auf dem PC, welche auf Änderungen von Smartphonesensorwerten wie beispielsweise Beschleunigungssensoren reagieren und die Ausgabemöglichkeiten des Smartphones nutzen.
\end{abstract}

\tableofcontents

\chapter{Einführung} \label{chap:intro}
Viele Programmierer oder Programmierwillige Anfänger mühen sich beim Programmierenlernen mit der Semantik von Programmiersprachen und grundlegenden algorithmischen Konzepten.
Akademische Übungsaufgaben senken die Lernmotivation durch rein virtuelle Aufgabenstellungen ohne Interaktionsmöglichkeiten.
Projekte mit Microcontrollern dagegen bieten eine praktische, fordernde und spielerische Einstiegsmöglichkeit.
Es werden kleine Projekte realisiert, die durch die Verwendung von Sensoren Programmierer einladen sich an Programmieraufgaben auszuprobieren.
Diese Eigenschaften sind sinnvoll, insbesondere bei Projekten für Programmierer mit wenig Vorwissen wie Schüler oder Erstemester-Studierende.
Gelerntes kann direkt angewandt werden.
Praktische Programmieraufgaben bieten für Programmieranfänger den besten Lerneffekt bei höchster Motivation \cite{learning_computer_programming}.
Die in Microcontroller integrierten Sensoren sind Voraussetzung um physikalische Eigenschaften in der realen Welt zu messen.
Programme auf dem Microcontroller können die die Sensoren auslesen und auf Änderungen der gemessenen Werte reagieren.
Sensoren, Microcontroller und das entwickelte Programm ermöglichen zusammen eine Bedienung durch Nutzer.
Selten verhält sich das Programm beim ersten Versuch korrekt.
Eine Anpassung des Codes ist nötig, bis das Fehlverhalten beseitigt ist.
Diese kontinierliche Weiterentwicklung mindert Ängste vor Änderungen des Codes, schafft Routine in der Entwicklung und damit ein tieferes Verständnis und Hintergrundwissen für die Problemstellung.

Microcontroller-Projekte benötigen allerdings kostspielige Einstiegs-Kits.
Ein Arduino-Development-Board kostet im Arduino-Shop über 80,00 € \cite{arduino_kit}.
Ein Großteil der Kosten entfällt zwar auf den eigentlichen Microcontroller, ein nicht unmittelbarer Teil jedoch auf Peripherie wie wie Breadboards, Verbindungskabel und Erweiterungsboards.
Die Peripherie-Anbindung setzt daneben Hintergrundwissen in elektrotechnischen Bereichen voraus, wie zum Beispiel den Verschaltungskonventionen bei Breadboards.
Dies stellt ebenfalls eine Einstiegshürde dar, die die eigentliche interaktive Lernerfahrung herauszögert und die Motivation senkt.

Smartphones dienen als Alternative für Microcontroller-Projekte für Einstiegs-Programmierer.
Integriert sind zahlreiche Sensoren wie Lagesensoren, Gyroskop oder Näherungssensoren.
Der Sensoren-Umfang ist vergleichbar mit dem von Microcontrollern.
Elektrische Bauteile konventioneller Microcontroller-Sets erlauben einen Fehlgebrauch, der im schlimmsten Fall in der Zerstörung von Komponenten enden kann.
Projekte mit Smartphones reduzieren dieses Risiko dadurch, dass Schaltkreise bereits intern verknüpft und somit von äußerlicher Fehlverwendung geschützt sind.
Ein weiterer Vorteil Smartphones gegebüber Microcontrollern liegt in der Verfügbarkeit.
Weltweit besaßen 2022 5,2 Mrd. Menschen ein Smartphone \cite{smartphone_users}.
Sie sind gerade unter Kindern, Jugendlichen und jungen Erwachsenen weit verbreitet.
Kinder besitzen häufig bereits mit 10 Jahren ein Smartphone \cite{bitkom_smartphones}.
Im Alltag wird es für Chats, Social-Media oder Spiele verwendet.
Sie sind also häufig bereits in Gebrauch und müssten für die Nutzung von Programmierprojekten nicht zusätzlich beschafft werden.
Durch Ihre eingesetzten Sensoren können Sie zuverlässig physikalische Umgebungseigenschaften messen.
Neben kabelgebundenen Übertragungsschnittstellen wie USB besteht auch die Möglichkeit sich mit drahtlosen Verbindungsmöglichkeiten wie WLAN zu verbinden.
Die Geräte sind zudem batteriebetrieben, was Lösungen ermöglicht die von einer Spannungsversorgung unabhängig sind.
Eine Einbindung von Smartphones ist in den meisten Entwicklungsumgebungen jedoch nicht möglich.
Visuelle und haptische Ausgaben auf dem Smartphone erfordern zudem eine mobile Anwendung, da Smartphone-Betriebssysteme keine nativen Ausgabemethoden außerhalb von Apps bieten.

Ziel der Arbeit ist es, eine Smartphone-Anwendung für visuelle Ausgaben sowie der Messung und Übertragung von Sensorwerten zu entwickeln.
Außerdem werden Schnittstellen in einer Programmierumgebung geschaffen, die die Interaktionsmöglichkeiten von Smartphones nutzbar macht.
Hierfür stellen Softwarebibliotheken Funktionsaufrufe zur Verfügung um Ausgaben auf dem Smartphone zu tätigen oder Sensorwerte auszulesen.
Das Smartphone reagiert auf die empfangen Anfragen und führt die entsprechenden Kommandos aus.
Zusammengesetzt besteht die Lösung aus einer programmiersprachenunabhängigen Programmierumgebung, einer Kontroll-Anwendung und einer mobilen Anwendung für Android Smartphones.
Für die Verwendung werden angehenden Programmiereren Beispielaufgaben gereicht.
Um die Beispielaufgaben zu bewältigen muss die Lösung auch Benutzungsmöglichkeiten bereitstellen.
Hierdurch werden Anforderungen an die in dieser Arbeit implementierte Lösung gestellt.
Die Aufgaben, Anforderungen und Rahmenbedingungen sind in Kapitel \ref{chap:Experimente} zu finden.
Die drei Komponenten Smartphone-App, Kontrollanwendung und Programmierumgebung und ihr Zusammenspiel werden
in Kapitel \ref{chap:architektur} vorgestellt.
Die dafür benötigten Nachrichtenformate werden in Kapitel \ref{chap:message_formats} gezeigt.
Ihr Zweck wird erklärt und und der Nachrichtenaustausch dort exemplarisch veranschaulicht.
Kapitel \ref{chap:app} behandelt die Funktionsweise und den Aufbau der Android-App im Detail.
Diese tauscht Nachrichten mit der Programmierumgebung aus.
Als Zwischenvermittlung fungiert das zentrale Kontrollprogramm, was in Kapitel \ref{chap:server_software} erklärt wird.
Einbindung, Nutzung, und externe Schnittstellen der Bibliotheken zur Android-App und dem Kontrollprogramm werden in Kapitel \ref{chap:libs} erklärt.
In Kapitel wird \ref{chap:eval} untersucht, ob die vorgegebenen Anforderungen erfüllt wurden.
Dort wird zudem die Verwendung der Lösung anhand einer Beispielaufgabe vorgestellt.
Schwierigkeiten die bei der Entwicklung auftraten werden in Kapitel \ref{chap:fazit} diskutiert.
Erweiterungsmöglichkeiten und Verbesserungen werden diskutiert.

\chapter{Smartphones als Microcontroller-Ersatz} \label{chap:Experimente}
Smartphones sind in sich geschlossene technische Geräte, die neben vordefinierten Verbindungsschnittstellen wie einem USB-Port, WLAN und Bluetooth keine weiteren Schnittstellen bieten um externe Hardware und Schaltungen anzuschließen und fernzusteuern.
Microcontroller-Schaltungen zum Programmierenlernen bieten meistens mehrere Ausgabemöglichkeiten wie LEDs, Lautsprecher oder Piepser.
Smartphones können diese Bausteine nicht anschließen aber virtuell darstellen.
Gewohnte Ausgabeelmente können virtualisiert werden.
Die Funktionen sind außerdem nicht nur von Mehrzweck-Ausgaben, wie LED-Grids begrenzt, die zum Beispiel für die Text- oder Bildanzeige verwendet werden können.
Zweckgebundene Elemente wie Textfelder, Textausgaben oder Bildausgaben in der App können beliebig kombiniert werden.
Darüber hinaus ist die Anordnung der jeweiligen Elemente frei wählbar, so dass das Layout anders als bei Microcontrollern auch im Nachhinein noch geändert werden kann.
Die Ausgabemöglichkeiten können in Kombination mit Sensor-Daten verwendet werden, um kleine Programmieraufgaben zu lösen.
Einige Beispiele werden in diesem Kapitel vorgestellt.
Da diese nicht auf einem Microcontroller, sondern einem Smartphone ausgeführt werden, müssen gewisse Rahmenbedingungen erfüllt sein, wie beispielsweise geringe Latenzen in der Sensordatenübertragung.
\section{Beispielprogrammieraufgaben}\label{sec:activities}
Praxisnahe Programmieraufgaben mit interessanten Aufgabestellungen motivieren Softwareentwickler.
Die in diesem Abschnitt vorgestellten Beispielaufgaben definieren das von Sensormesswerten abhängige Verhalten interaktiver Programme.
Die Aufgabenstellungen sind in Tabelle \ref{tab:excercises} aufgeführt.
Für jede Aufgabe werden die benötigen Sensortypen und Ausgabeschnittstellen beschrieben.
Leserinnen und Leser werden in der Entscheidungsfindung durch die Angabe eines dreistufigen Schwierigkeitsgrades unterstützt.
Dies soll verhindern, dass sich unerfahrene Programmierer mit komplizierten Aufgaben zu Anfang überfordern.
\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|c|p{2cm}|c|}
      \hline
      \textbf{Name der Aufgabe} & \textbf{Benötigte Sensoren} & \textbf{Verwendete Ausgaben} & \textbf{Schwierigkeitsgrad} \\
      \hline
      Disco & - & Led & + \\
      \hline
      Würfeln & Lagesensor & Textfeld &+ \\
      \hline
      Diebstahl-Alarm & Näherungssensor & Textfeld, Led, Vibration & ++ \\
      \hline
      Klatsch-Zähler & Mikrofon & Textfeld & ++ \\
      \hline
      Dreh-Zähler & Lagesensor & Textfeld & +++ \\
      \hline
  \end{tabular}
  \caption{Beispielprogrammieraufgaben}
  \label{tab:excercises}
\end{table}

In der Aufgabe \textit{Disco} soll eine virtuelle LED für eine Zeitdauer von 500 ms grün und anschließen 500ms rot leuchten.
Sensoren sind in dieser Aufgabe überflüssig, da die LED-Ausgabe unabhängig von Sensormesswertänderungen ausgeführt wird.
Aus diesem Grund ist die Aufgabe als Einfach eingestuft.

In der Aufgabe \textit{Würfeln} soll ein Schütteln des Geräts erkannt werden.
Zur Verwendung kommt dabei ein Lagesensor zum Einsatz welcher Gerätebeschleunigungen messen kann.
Wird ein Schütteln erkannt, soll auf dem PC eine Zufallszahl generiert werden.
Anschließend wird diese auf dem Gerät in einem Textfeld ausgegeben.
Der Schwierigkeitsgrad wird ebenfalls auf Einfach eingeschätzt, da die Aufgabe unter Verwendung eines Sensors und einer Ausgabe lösbar ist.

In der Aufgabe \textit{Diebstahl-Alarm} wird unter Verwendung des Näherungssensors das örtliche Umfeld des Geräts auf eine Annäherung kontrolliert.
Wird eine Annäherung festgestellt, wird ein alarmierender Text im Textfeld ausgegeben.
Zusätzlich soll die LED die wie in Aufgabe \textit{Disco} die Farbe wechseln.
Neben den visuellen ausgaben wird die Vibrationsfunktion als haptisches Feedback benötigt.
Im Falle einer Annäherung, soll das Gerät fünf mal vibrieren.
Der Schwierigkeitsgrad der Aufgabe ist als Mittel eingestuft, da hier zwischen Alarm- und Normalzustand unterschieden werden muss.
Entfernt sich eine Person, muss der Alarm-Zustand verlassen werden können.
Alle Ausgaben werden auf ihren initialwert zurückgesetzt.

Bei der Aufgabenstellung \textit{Klatsch-Zähler} muss für einen definierten Zeitraum die Anzahl der Händeklatscher gemessen werden.
Diese Anzahl wird anschließend im Textfeld des Geräts ausgegeben.
Zur Verwendung kommen hierfür das Mikrophon als Ein- und das Textfeld als Ausgabe.
Die Schwierigkeit ist auf \textit{Mittel} angesetzt, da die Messwerte von Händeklatschern unterschiedliche Intensitäten aufweisen.
Um einen Händeklatscher zu identifizieren ist es nötig Grenzwerte zu ermitteln um Sie von normalen Hintergrundgeräuschen abzugrenzen.
Eine Visualisierung der Messdaten kann bei dieser Festlegung helfen.

Bei der letzen Aufgabe \textit{Drehzähler} soll der Programmierer das Device innerhalb eines definierten Zeitraums drehen und anhand der Messdaten die Anzahl der Umdrehungen ermitteln.
Diese Anzahl soll anschließend im Textfeld auf dem Gerät ausgegeben werden.
Zur Verwendung kommen hier ebenfalls der Lagesensor als Sensoreingabe und das Textfeld als Ausgabe.
Die Aufgabe ist als Schwer bewertet, da hier Wiederholungen in einer Werteabfolge erkannt werden müssen, welche jedoch wie bei der Aufgabe \textit{Klatsch-Zähler} in ihrer Größe variieren können.
Abhängigkeiten zwischen den Messwertergebnissen erschweren eine Umdrehungserkennung zusätzlich.

\section{Anforderungen der Implementierung}\label{sec:anforderungen}
Aus den Beispielaufgaben leiten sich Anforderungen an die implementierte Lösung ab.
Geringe Latenzen sind bei der Sensordatenübermittlung für ein responsives Verhalten von Programmen nötig.
Sie tragen zur Lernerfahrung bei, da sich physikalische Änderungen unmittelbar auf das Verhalten des entwickelten Progamms auswirken.
Eine Verkürzung der Latenzen ist von mehreren Faktoren abhängig.

Für die Übermittlung von Sensorwerten müssen diese initial vorliegen.
Sensormessprozesse müssen gestartet und Sensoren ausgelesen werden, was die Latenzzeiten erhöht.
Sensormessungen sollten daher nicht erst nach einer Anfrage oder einem Ereignis, sondern direkt zu Anfang gestartet werden und kontinuierlich messen.
Der Versand der Sensorwerte wird durch den Transportweg zwischen Smartphone und Programmierumgebung und deren lokale Gegebenheiten verzögert.
Smartphones bieten keine kabelgebundenen Netzwerkschnittstellen.
Latenzen können je nach Mobilfunk- bzw WLAN Standard, Umwelteinflüssen und der Geräteanzahl in Funkzellen variieren.
Für Latenzen dient die Round-Trip-Time (RTT) als Messgröße.
Sie beschreibt die Zeitdauer der Übermittlung einer Nachricht über Hin- und Rückweg eines Hosts zu einem Anderen.
Präventionsprinzipen wie CSMA/CA verhindern bei WLAN Verbindungen Interferenzen, erhöhen allerdings die Latenzen.
Während sie bei Standards wie WLAN 802.11b ca. 10 ms beträgt, kann Sie bei UMTS auf 300 ms bis 400 ms ansteigen \cite{network_latencies} .
Zudem ist Sie variabel, was bei einer synchronen Übertragung zu ungewollten Verzögerungen führt.
Um die Latenz des Transportweges geringer darzustellen müssen Sensorwerte zwischengespeichert werden, um einen Puffer aufzubauen auf den in Fällen erhöhter Latenz zugegriffen werden kann.
Eine weitere Latenz-Optimierung ist durch den Einsatz effizienter Protokolle möglich.
Der Verlust weniger Sensorwerte ist für die Funktionsweise des Programms unerheblich.
Verbindungsorientierte Protokolle erhöhen die Menge der zu sendenen Nachrichten pro Sensorwert.
Verbindungslose Protokolle sind deshalb zu bevorzugen.

Die implementierte Lösung muss einen benutzerfreundlichen Nutzungszugang  für Programmierer und die Anbindung ihrer Programme bieten.
Boilerplate-Code soll reduziert werden, um die Verwendung zu erleichtern.
Die angebotene Funktionalität soll mit möglichst wenig Vorwissen nutzbar sein.
Auf serialisierte Ausgabeformate muss verzichtet werden.
Funktionen müssen Rückgabewerte in Form von primitiven Datentypen zurückgeben.
Für die Bedienung aller Ausgabemöglichkeiten des Smartphones wird muss die Lösung eine Funktion zur programmierung bereitstellen.
Das Einbinden in bestehende Entwicklungsumgebungen ist neben der benutzerfreundlichen Schnittstellengestaltung Voraussetzung für die Nutzung der Lösung.
Die Entwicklungsumgebung Eclipse ist im Labor-Kontext weit verbreitet.
Da es sich um eine plattformunabhängige IDE handelt, muss auch die Lösung plattformübergreifend in diese Entwicklungsumgebung integrierbar sein.
Nachrichtenabläufe sollen nachvollziehbar sein um fehlerhafte Konfigurationen rasch zu identifizieren und zu korrigieren.
Hierfür muss es eine Logging-Funktion geben die den Nachrichtenverlauf aufzeichnet und ausgibt.
Programmierer können anhand der Logeinträge den Versand nachvollziehen wodurch Fehler ersichtlich werden.

Neben den Netzwerktechnischen- und Nutzungsbezogenen Anforderungen muss die Lösung auch Ausgabemöglichkeiten über die grafische Benutzeroberfläche einer Smartphone-App bereitstellen.
Teil dieser Oberfläche ist eine farbwechselbare Signal-LED.
Zur Ausgabe von Texten und Zeichen muss ein Textfeld implementiert werden.
Durch zwei Tasten muss der Nutzer außerdem mit der Anwendung interargieren können.
Neben den optischen Ausgaben bzw. Bedienelementen muss die Smartphone-App auch haptische Ausgaben wie Vibrationen umsetzen können.
Für die Einstellung von Vibrationsmustern muss eine Vibrationszeitdauer konfigurierbar sein.
\chapter{Architektur} \label{chap:architektur}
Die Lösung besteht aus den drei Komponenten Programmierumgebung, Kontrollprogramm und Android-Anwendung die zur korrekten Funktionsweise miteinander kommunizieren.
Eine Übersicht des Aufbaus ist in Abbildung \ref{fig:design} dargestellt.
\begin{figure}[htbp]
\centering
% \includegraphics[width=.9\textwidth]{zeichnung.eps}
\includegraphics[width=\textwidth]{images/framework.pdf}
\caption{System-Aufbau}
\label{fig:design}
\end{figure}
Um mit dem Smartphone zu interargieren bietet die Programmierumgebung eine Bibliothek mit Schnittstellen in Form von Funktionen.
Eine Einbindung in bestehenden Programmcode des Programmierers ermöglicht deren Nutzung.
Zur Unterstützung der Verständlichkeit für angehende Programmierer wurde bei der Entwicklung auf die Implementierung von Funktionen mit asynchronem Verhalten verzichtet.
Die Kontrollanwendung, welche ebenfalls auf dem lokalen PC betrieben wird, dient der Nachrichtenvermittlung zwischen Smartphone-App und Programmierumgebung. 
Führt ein Programmierer einen Funktionsaufruf der Bibliothek aus, übermittelt die Bibliothek diesen per UDP dem Kontrollprogramm welches über die weitere Verfahrensweise entscheidet und die Nachricht gegebenenfalls per MQTT an das Smartphone überträgt, wie dies zum Beispiel bei einer Ausgabeanfrage der Fall ist.
Zusätzlich bietet die Bibliothek indes Funktionen die Sensormessdaten zurückgeben.
Diese werden von der Smartphone-App in regelmäßigen Abständen zur Zwischenspeicherung an die Kontrollanwendung gesendet.
Bei Eingang einer Sensorwert-Anfrage sendet die Kontrollanwendung den zuletzt von der Smartphone-App übermittelten Wert an die Bibliothek zurück.
Die Smartphone-Anwendung beginnt zum Startvorgang mit der Erhebung sowie Übermittlung der Sensordaten und reagiert auf Ausgabe-Anfragen seitens der Kontrollanwendung.

Für die Übermittlung der Nachrichten werden die Protokolle MQTT und UDP verwendet.
MQTT ist ein auf TCP basierendens Client-Server-Protokoll.
Durch einen 2 Byte großen Header und maximalen Payload-Größe von 260 MB ist es leichtgewichtig und gleichzeitig flexibel.
Nachrichten werden an einen MQTT Broker gesendet, der die Nachrichten dann an alle Clients weiterreicht die das Topic auf dem die Nachricht gesendet wurde abboniert haben.
Die UDP-Kommunikation zwischen Bibliothek und Kontrollprogramm auf dem lokalen PC wird über ein Loopback-Interface umgesetzt um die Latenzzeiten zwischen Programmierumgebung und Kontrollprogramm zu minimieren.
Als Nachrichtenformat wird JSON verwendet.
Das menschlesbare, kompakte Nachrichtenformat ist weit verbreitet und wird von vielen Softwarebibliotheken unterstützt.

\chapter{Nachrichtenformate}\label{chap:message_formats}
Ein einheitliches Kommunikationsformat ist für den Nachrichtenaustausch unabdingbar.
Der zur Übermittlung ausgearbeitete Standard definiert die Nachrichten in einem Klartextformat.
Als Darstellungsform wird JSON verwendet.
Die in einer Datei gespeicherten Nachrichten-Vorlagen werden in der Bibliothek, dem Kontrollprogramm und in der Smartphone-App eingelesen
So sind die Nachrichten in jeder Komponente gleich.
Es gibt unterschiedliche Nachrichtentypen für verschiedene Zwecke.
Diese sind in Tabelle \ref{tab:message_types} aufgeführt.
Um besser nachvollziehen zu können welche Kommunikationspartner welche Nachrichten austauschen, sind außerdem Quelle und Ziel und das verwendete Netzwerkprotokoll angegeben.
\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|p{30mm}|c|c|}
      \hline
      \textbf{Nachrichtentyp} & \textbf{Quelle} & \textbf{Ziel} & \textbf{Netzwerkprotokoll}\\
      \hline
		sensor\_request & Bibliothek & Kontrollprogramm & UDP\\
       \hline
       sensor\_response & Kontrollprogramm & Bibliothek & UDP\\
       \hline
		update\_request & Smartphone & Kontrollprogramm & MQTT\\
       \hline
		rpc\_request & Bibliothek, Kontrollprogramm & Smartphone & UDP/MQTT\\
       \hline
		rpc\_response & Smartphone, Kontrollprogramm & Bibliothek & UDP/MQTT\\ 
       \hline
  \end{tabular}
  \caption{Nachrichten-Typen}
  \label{tab:message_types}
\end{table}

\textit{Sensor\_request}s kommen zum Einsatz, wenn Programmierer einen Sensorwert abfragen.
Dann wird die Nachricht von der Bibliothek an das Kontrollprogramm gesendet.
Dieses hat vom Smartphone übermittelte Sensorwerte zwischengespeichert.
Nach Eingang ermittelt das Kontrollprogramm den gewünschten Sensorwert.
Die Angabe des gewünschten Sensors wird im Feld \texttt{sensor\_type} beschrieben.
Alle Sensortypen besitzen ein festgelegtes Kürzel.
Dadurch können ihre Werte in der Datenbank in der Kontrollanwendung addressiert werden und Messwerte eingespeichert oder zurückgegeben werden.
Die Sensortyp Kürzel sind in Tabelle \ref{tab:sensor_types} zu finden. 
\begin{table}[htbp]
  \centering
  \begin{tabular}{|c|c|}
      \hline
      \textbf{TYPE-Kürzel} & \textbf{Beschreibung} \\
      \hline
      accel\_xyz & Lagesensor für die X, Y oder Z-Richtung \\
      \hline
       gyro\_xyz & Gyroskopsensor für die X, Y oder Z-Richtung \\
      \hline
      prox & Näherungssensor \\
      \hline
  \end{tabular}
  \caption{Sensor-Kürzel mit Beschreibung}
  \label{tab:sensor_types}
\end{table}
Ist er in der gespeicherten Datenstruktur zu finden, wird er in einer neuen Nachricht im Nachrichtenformat \textit{sensor\_response} zurückgesendet.
Der gespeicherte Wert ist im Feld \texttt{sensor\_value} zu finden.
Die Antwort wird von der Bibliothek angenommen und anschließend an das Programm des Entwicklers zurückgegeben, das den Sensortwert ursprünglich forderte.
Sensor-Abfragen laufen blockierend ab.
Das bedeutet, dass jede Sensor-Wert-Anfrage immer erst eine Rückgabe erhalten muss, bevor die nächste Sensor-Wert-Anfrage gestartet werden kann.
Es ist unmöglich, dass die Kontrollanwendung zwei Sensor-Wert-Anfrage gleichzeitig erhält und die Antworten in umgekehrter Reihenfolge zurücksendet, was eine Vertauschung der Sensorwerte bedeutete.
Durch  Angabe des ursprünglich geforderten Sensor-Typs in der Antwort könnte dies verhindert werden, ist allerdings nicht nötig.
Sensorwerte müssen kontinuierlich vom Smartphone aktualisiert werden, damit das Kontrollprogramm immer den aktuellste Wert zurückliefern kann.
Die Android-App sendet daher in periodischen Abständen Nachrichten des typs \textit{update\_request} an das Kontrollprogramm.
Sie kann für jede Sensor-Art verwendet werden.
Übermittelt wird sowohl der Sensor-Typ, als auch der gemessene Sensor-Wert.
Die Kontrollanwendung kann den den Wert über den Typ zuordnen und in den internen Datenpuffer eintragen.
Der gesamte Ablauf für Sensoranfragen ist in Abbildung \ref{fig:message_flow_requests} dargestellt.
\begin{figure}[htbp]
\centering
% \includegraphics[width=.9\textwidth]{zeichnung.eps}
\includegraphics[width=.9\textwidth]{images/message_flow_sensor.pdf}
\caption{Nachrichtenablauf der Sensordatenübermittlung}
\label{fig:message_flow_requests}
\end{figure}
Zu sehen sind die drei Komponenten Bibliothek, Kontrollprogramm und App auf dem Smartphone.
Die Bibliothek sendet sensor\_requests per UDP an das Kontrollprogramm.
Dieses antwortet über UDP mit einer sensor\_response.
Währenddessen sendet die App auf dem Smartphone kontinuierlich update\_requests per MQTT um der Kontrollanwendung neue Messergebnisse mitzuteilen.


Neben den Sensordaten betreffenden Nachrichten existieren auch Ausgabe-Kommandos um Ausgaben in der Smartphone-App umzusetzen.
Es wird unterschieden Ausgaben mit und ohne Rückgabewert.
Für erstere gibt es den Nachrichtentyp \textit{rpc\_request}.
RPC steht für Remote Procedure Call und bezeichnet Clientseitige Funktionsaufrufe, die auf einem Server ausgeführt werden.
Die Bezeichnung entspricht nicht dem Konzept, da die die Smartphone-App in diesem Fall die Rolle des Servers einnehmen würde.
Die Voraussetzung einer Client-Server-Anwendung ist dadurch nicht gegeben.
Kommunikationspartner tauschen auf gleicher Ebene Daten aus.
Die Bezeichnung wurde unter dem Fokus auf der entfernten Ausführung einer Funktion gewählt.
Der Nachrichtentyp enthält die Felder \texttt{command} und \texttt{value}.
Ersters spezifiziert das Ausgabe-Kommando, das Zweite die Größe des Parameters für das Ausgabekommando.
Es ist fast immer befüllt.
Vereinzelt gibt es jedoch auch Kommandos die keinen Parameter benötigen.
Dann bleibt dieses Feld leer.
Die Nachricht wird von der Bibliothek per UDP an die Kontrollanwendung und von dort aus per MQTT an das Smartphone gesendet.
Die Smartphone-App nimmt die Anfrage an und führt die Ausgabe aus.
Manche Kommandos erheben zusätzlich einen Rückgabewert.
Damit dieser vom Smartphone zurück an die Bibliothek gesendet werden kann, gibt es das Nachrichtenformat \textit{rpc\_response}.
Dieses wird erst per MQTT an das Kontrollprogramm und von dort aus per UDP an die Bibliothek gesendet.
Wie bei sensor\_responses können sich die Antworten nicht gegenseitig überholen, was die Übertragung des zugrundeliegenden Ausgabe-Kommandos überflüssig macht.
Nur der ermittelte Wert des Kommandos ist relevant und wird in der Nachricht übermittelt.
Der Nachrichtenablauf wird in Abbildung \ref{fig:message_flow_rpc} zusammengefasst.
\begin{figure}[htbp]
\centering
% \includegraphics[width=.9\textwidth]{zeichnung.eps}
\includegraphics[width=.8\textwidth]{images/message_flow_rpc.pdf}
\caption{Nachrichtenablauf der RPC-Anfragen}
\label{fig:message_flow_rpc}
\end{figure}
Zu sehen sind die drei Komponenten Bibliothek, Kontrollprogramm und Android-App.
Die Bibliothek sendet rpc\_requests per UDP an das Kontrollprogramm.
Dieses leitet die Nachricht per MQTT direkt weiter an die App.
Dort wird das gewünschte Kommando ausgeführt.
Fällt ein Rückgabewert an, wird eine rpc\_response generiert und vom Smartphone per MQTT zurück an die Kontrollanwendung gesendet.
Diese leitet die Nachricht dann per UDP weiter an die Bibliothek.


\chapter{Implementierung der Komponenten}
In diesem Kapitel werden die Designentscheidungen in der Implementierung der drei Komponenten Android-Anwendung, Kontrollanwendung und Programmierumgebung erörtert.
Der Fokus liegt auf der internen Struktur der jeweiligen Komponenten ihrer Verknüpfung.
Startabläufe werden dargelegt und die Funktionsweisen der einzelnen Komponenten vermittelt.

\section{Android Anwendung}\label{chap:app}
Die Android-Anwendung ist eine der drei zentralen Bestandteile des Frameworks.
Sie dient dazu Sensormessprozesse zu starten, Sensordaten zu übermitteln und Ausgabe-Kommandos auszuführen.
Für diese bietet Sie unterschiedliche UI-Elemente in einer Activity an, der RootActivity.
Diese sind: eine Signal-Led, ein Textfeld und zwei Buttons.
Neben UI Elementen gibt es zusätzlich noch eine Vibrationsausgabe. 
Jedes Messergebnis wird anschließend per MQTT an die Kontrollanwendung gesendet.
Versandt werden die Sensorwerte über einen Service, der im Hintergrund ausgeführt wird.
Dieser reagiert ebenfalls auf eingehende Anfragen um Ausgaben auf dem Smartphone auszulösen.
Gibt die Ausgabe einen Rückgabewert diese an die Kontrollanwendung weitergereicht.

Die Anwendung misst in periodischen Zeitabständen Sensorwerte und sendet Sie an die Kontrollanwendung.
Messungen werden über SensorEventListener realisiert.
Diese starten Messvorgänge und ermitteln in periodischen Zeitabständen den aktuell vorliegenden Messwert.
Verwendete Sensoren sind beispielsweise der Lagesensor oder das Gyroskop.

Die Erhebung der Messwerte erfolgt zum Start der Anwendung.
Ein Ablaufplan ist in Abbildung \ref{fig:app_flow} zu sehen.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/app_ablauf}
  \caption{Ablaufdiagramm Android Anwendung}
  \label{fig:app_flow}
\end{figure}
In der Root-Activity werden zuerst alle UI-Elemente eingebunden um Sie über Kommandos zu manipulieren.
Anschließend werden Konfigurationsdaten eingelesen.
Insgesamt gibt es zwei Konfigurationsdateien: config.json und protocol.json.
In Ersterem ist zum Beispiel der Hostname des MQTT-Brokers, der Port oder das Topic definiert.
Diese Daten sind für die Übermittlung der Nachrichten per MQTT wichtig.
In protocol.json wird die Form der für das Smartphone relevanten Nachrichtenformate update\_request und rpc\_response definiert.
Außerden sind dort die unterstützten Sensoren und Ausgabekommandos beschrieben.
Relevant werden diese bei der Entscheidungsfindung bei Eingang eines rpc\_requests, wenn determiniert werden muss welche Aktion die Nachricht beeinhaltet.
\\
Nach dem Einlesen der Konfigurationen wird der zur Kommunikation verwendete MQTT Service eingebunden.
Dies geschieht asynchron.
Über eine ServiceConnection wird beim erfolgreichen einbinden über eine Callback-Methode der weitere Verlauf definiert.
Die Root-Activity speichert dann die Referenz auf den Service und der Service die Referenz auf die Root-Activity.
Grund für dieses gegenseitige Einbinden ist, dass Nachrichten im MQTT Service in einem seperaten Thread behandelt werden.
Bei RPC-Requests müssen jedoch UI-Elemente verändert werden können.
Dies ist ohne weiteres nicht aus dem Service heraus möglich.
Mit einer Referenz auf die Activity kann der Service UI-Ändernde Funtionen auf der Activity ausrufen.
Android unterbindet jedoch UI-Manipulationen durch Threads die nicht der UI-Thread sind.
Dieses Problem wird durch die Methode \textit{runOnUiThread} umgangen, welche die Änderung in der Ausführungswarteschlange des UIThreads einreiht.
Der Service baut eine Verbindung zu einem MQTT Server auf.
Beim Einbinden des MQTT Servers stellt dieser eine Verbindung zu einem in config.json definierten MQTT-Broker und Topic her.
Ist der Service final eingebunden können die Sensormessprozesse gestartet werden, da Messdaten nun zuverlässig gesendet werden können.
Verschiedene SensorEventListener werden nun gestartet und zentral in einem SensorEventListenerContainer gesammelt gespeichert und die Messprozesse jeweils angestoßen.
Somit ist die Startroutine der Mobilen Anwendung abgeschlossen.
Auf Nachrichten wird nun nur noch im MQTT-Service in einem MessageListener mit entsprechendem Callback reagiert.

Die Funktionsweise der Sensordatenübertragung wird in Abbildung \ref{fig:sensor_event_listener} nocheinmal zusammenfassend dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=.9\textwidth]{images/sensor_event_listener.png}
  \caption{Ablaufdiagramm SensorEventListener}
  \label{fig:sensor_event_listener}
\end{figure}
Die Klasse \textit{SmartBitEventListenerContainer} beeinhaltet SensorEventListener für alle Arten von untertstützten Sensoren.
Der Container dient lediglich der Datenhaltung.
Aufgabe der SensorEventListener ist es auf Sensorwert-Änderungen zu reagieren und eine entsprechende Callback-Funktion aufzurufen.
In dieser werden dann über statische Methoden der Klasse \textit{JSONMessageWrapper} update\_requests generiert und der gemessene Wert eingesetzt.
Die so generierte Nachricht wird anschließend über den gebundenen MQTT-Service an das vorher definierte Topic versendet.

Die Anwendung ist nun betriebsbereit und beginnt bereits erste Nachrichten an die Kontrollanwendung zu senden.
Übermittelt werden die Sensordaten an den Broker mit einer QOS-Stufe von 0.
Verluste von update\_requests sind unproblematisch, da es je nach Taktung sehr schnell neue Sensorwerte gibt die übertragen werden können.
Eine exakte Zustellung ist hier nicht notwendig und verlangsamt eher den Übertragungsprozess.

Smartphones beeinhalten Sensoren die Daten über die Umgebungseigenschaften erfassen.
Dazu zählen Beispielsweise Bewegung, Näherung, aber auch Temperatur oder Luftdruck.
In der Lösung besteht ihr Zweck darin auf Änderungen der Werte zu reagieren.
Für unterschiedliche Aufgaben werden unterschiedliche Sensoren benötigt.
Beispielsweise word für \textit{Diebstahl-Alarm} nur der Näherungssensor verwendet, für \textit{Dreh-Zähler} der Lagesensor.
Insgesamt werden in der Android Anwendung werden folgende Sensortypen verwendet: Lineare Beschleunigungssensoren, Gyroskop und Annäherungssensor.

Beschleunigungs- bzw. Lagesensoren messen die Beschleunigung in $m/s^2$ für die drei Bewegungsrichtungen: X-, Y- und Z-Achse in einem festgelegten Zeitraum.
Die Erdbeschleunigung ist auch in diesen Messwerten enthalten.
Diese muss für die bereinigten, realen Werte von den aufgenommenen Werten subtrahiert werden\cite{accel_g}.
Messeinheiten unterscheiden sich je nach Sensor.
Das Gyroskop misst keine Beschleunigung sondern die aktuelle Geschwindigkeit in $rad/s$ der gleichen Achsen.
Zur Übersicht sind diese in Abbildung \ref{fig:and_axes} zu dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=.7\textwidth]{images/android_axes.png}
  \caption{Android-Koordinatensystem}
  \label{fig:and_axes}
\end{figure}
Die Frequenz mit der Messwerte erfasst werden kann manuell angegeben werden.
Hierfür stehen vier Stufen zur Auswahl.
\begin{table}[htbp]
  \centering
  \begin{tabular}{|c|p{4cm}|}
      \hline
      \textbf{Bezeichnung} & \textbf{Verzögerung} \\
	  \hline
      SENSOR\_DELAY\_FASTEST & Keine. Verwendet die Frequenz des Sensors.\\
      \hline
      SENSOR\_DELAY\_GAME & 20 ms\\
      \hline
      SENSOR\_DELAY\_UI & 60 ms\\
      \hline
      SENSOR\_DELAY\_NORMAL & 200 ms\\
      \hline
  \end{tabular}
  \caption{Sensor-Taktgeschwindigkeiten\cite{sensor-takt}}
  \label{tab:sensor_speeds}
\end{table}
In der Android-APP erfolgen alle Messungen mit SENSOR\_DELAY\_NORMAL.
Die Stufe gilt jedoch nicht als festes Limit, sondern eher als Richt-Frequenz.
Android kann die reale Frequenz auch erhöhen.
Nicht alle Smartphones besitzen alle Sensoren.
Daher wird beim Start überprüft ob der Sensor auch wirklich vorhanden ist.
Ist er es nicht, wird auch keine Messung gestartet.


\section{Kontrollanwendung}\label{chap:server_software}

Für Vermittlung zwischen den Komponenten fungiert eine Server-Anwendung.
Sie ist in Python geschrieben und vermittelt zwischen UDP-Anfragen auf der einen Seite vom Client aus und MQTT-Anfragen vom Smartphone auf der anderen Seite.
User können über die Library RPC-Anfragen oder Sensor-Anfragen an den Server stellen.
Dies geschieht in form von JSON-Anfragen die per UDP übermittelt werden.
Der Server ist unter der localhost-Adresse 127.0.0.1 auf dem Port 5006 erreichbar.
Für die MQTT-Verbindung kommt dabei die unter OpenSource-Liznenz stehende MQTT-Library Paho der Eclipse-Foundation zum Einsatz. \cite{paho}

Die Serveranwendung mit dem Namen server.py ist aufgeteilt in einen Datenverwaltungsteil, DataHandler, und eine MQTT Anbindung, MQTTHandlerThread.
Da die Sensorwerte des Smartphoens vorrätig gehalten werden, wird außerdem eine Datenklasse für diese, SensorDB, intern gehalten.
Eine Übersicht über die Komponenten ist Abbildung \ref{fig:serverUml} zu entnehmen.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/ServerUml}
  \caption{UML Digaramm Server}
  \label{fig:serverUml}
\end{figure}
DataHandler wiederrum teilt sich nochmal auf in vier seperate Funktionen, die als Threads nebenläufig laufen: MqttRequestHandler, UDPRequestHandler, UDPRequestQueueWorker und AnswerQueueWorker.

Die Funktionsweise und Zwecke dieser Threads wird im Folgenden an zwei Beispielen erläutert.
Für das erste Beispiel wird Abbildung \ref{fig:serverMqttReqPath} betrachtet.
Zu sehen ist ein MQTT-Request, also eine Anfragen des Smartphones, dass über MQTT an den Server gesendet wird.
Schnittstellen zu MQTT sind in der Abbildung grün, Schnittstellen zur Library per UDP, sind blau markiert.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/MqttRequestServerPath}
  \caption{Ablaufdiagramm MQTT Request}
  \label{fig:serverMqttReqPath}
\end{figure}
Erreicht ein MQTT Request den Server wird es im MQTTHandlerThread entgegengenommen.
Dieser setzt die Nachricht in eine MQTTRequestQueue ein.
Der MQTTRequestHandler des DataHandlers wartet bis ein Eintrag in der Queue vorhanden ist und nimmt gegebenenfalls eine Nachricht.
Daraufhin wird derTyp des Requests bestimmt.
Handelt sich um ein Sensorupdate muss nur der Sensorwert in der Datenbank aktualisiert werden.
Handelt es sich um eine rpc\_response, also um eine Antwort auf eine vorausgegangenes rpc\_request, dass einen Rückgabewert fordert, wird das request in eine udp\_answer\_queue eingefügt.
Der AnswerQueue Worker wartet, ähnlich wie der MQTT Request Handler, bis eine neue Nachricht vorhanden ist die per UDP an den Client gesendet werden soll und sendet diese dann gegebenfalls ab.

Das zweite Beispiel befasst sich mit dem Ablauf eines UDP-Requests, also einer Anfrage die mithilfe der Library gesendet wurde.
Der Ablauf ist in Abbildung \ref{fig:serverUDPReqPath} dargestellt.
Wie auch schon in der letzten Abbildung sind alle Schnittstellen zum Smartphone grün und alle Schnittstellen zur Library blau markiert.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/UDPRequestServerPath}
  \caption{Ablaufdiagramm UDP Request}
  \label{fig:serverUDPReqPath}
\end{figure}
Erreicht ein UDP Request den Server wird es vom UDPRequestQueue-Worker in eine UDP Request Queue gelegt.
Der UDPRequestHandler-Thread entnimmt die Nachricht und bestimmt den Anfragentyp.
Handelt es sich um eine Anfrage des Types RPC\_Request soll sie Aktionen auf dem Smartphone auslösen.
Sie muss an das Smartphone gesendet werden, was über MQTT möglich ist.
Dafür wird Sie ineine MqttAnswerQueue eingesetzt.
Der MQTTHandlerThread entnimmt Sie und sendet Sie per MQTT ab.
Ist Request hingegen ein SensorRequest, also eine Anfrage auf die ein Sensorwert geantwortet werden soll wird der nachgefragte Sensorwert über die Klasse SensorDB entnommen und in die Udp\_answer\_queue eingetragen.
Der AnswerQueueWorker entnimmt die Anfrage und sendet Sie per udp an die Library zurück.

Zusammenfassend erfüllen die Komponenten folgende Aufgaben.
Der MQTTHandlerThread nimmt Nachrichten direkt per MQTT an und gibt die Anfrage weiter.
Außerdem sendet er Nachrichten per MQTT, falls welche anfallen.
Der MQTTRequestHandler kümmert sich um das Verfahren von MQTT Requests.
Der UDPRequestQueue Worker nimmt wie der MQTTHandlerThread Anfragen die per UDP übermittelt wurden an und gibt Sie zur Behandlung entsprechend weiter.
Er sendet jedoch im Gegensatz keine Responses zurück.
Hierfür gibt es den AnswerQueueWorker, dessen einzige Aufgabe es ist Antworten per UDP zurück zu übermitteln.

Die Kommunikation zwischen den Threads funktioniert über synchronisierte Queues des queue-Moduls\cite{python_queue} der cpython Implementierung.
Es handelt sich um eine threadsichere Monitorklasse, die einen gleichzeitigen Zugriff zweier unterschiedlicher Threads durch Locks verhindert.

\section{Programmierumgebung}\label{chap:libs}
Die Programmierumgebung ist die Schnittstelle, die Programmierer für die Interaktion mit dem Smartphone verwenden.
Sie besteht aus einer Bibliothek, die Funktionen anbietet mit denen Programmierer Sensorwerte einlesen, oder Ausgaben auf dem Smartphone tätigen können.
Sie können die Funktionen in ihren bestehenden Quellcode einbinden und die Funktionen dort verwenden.
Die Bibliothek ist in den Programmiersprachen C, Java und Python vorhanden, damit Sie mit verschiedenen Programmiersprachen genutzt werden kann.
In Java und Python ist Sie zudem Plattformunabhängig.
Für C gibt es zwei Bibliotheken: Eine für Unix- und eine für Windows-Systeme.
In C ist die Bibliothek prozedural mit statischen Methoden, in Java und Python objektorientiert implementiert.

Werden die bereitgestellten Funktionen aufgerufen, werden standardisierte Anfragen im JSON-Format generiert und an die Kontrollanwendung gesendet.
Diese sendet die Daten gegebenenfalls an das Smartphone weiter oder antwortet direkt.
Eine Übersicht ist in Abbildung \ref{fig:Schnittstelle Bibliothek} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=.8\textwidth]{images/lib_server_connection}
  \caption{Schnittstellen der Bibliothek}
  \label{fig:Schnittstelle Bibliothek}
\end{figure}

Alle Anfragen werden über das UDP-Protokoll unter IPv4 versendet.
Das Kontrollprogramm ist auf dem Port 5006 erreichbar, Bibliotheken auf dem Port 5005.
Beide kommunizieren über die localhost-Adresse 127.0.0.1.
Dadurch werden Datagramme über das Loopback-Interface gesendet.
Das Loopback-Interface ist eine virtuelle Netzwerk-Schnittstelle des Betriebssystems eines PCs.
Pakete werden nicht über externe Netzwerk-Schnittstellen wie Netzwerkkarten versendet, sondern verbleiben im Netzwerk-Stack des Betriebssystems.
Die Latenzen sind dadurch mit weniger als 1 ms äußerst gering.
Zum Senden und Empfangen von Anfragen werden Sockets verwendet.
Für das Empfangen von Paketen müssen diese gebunden werden, für Sendevorgänge nicht.

Bei der Erstellung eines Phone-Objekts in Python und Java werden die Nachrichtenvorlagen für Anfragen und Antworten aus der Datei \texttt{protocol.json} geladen.
Die Datei muss sich im Dateisystem im gleichen Ordner befinden wie die Bibliothek.
Für die C-Bibliothek sind alle Methoden statisch definiert.
Es gibt somit keinen Start-Punkt zu dem die Datei \texttt{protocol.json} eingelesen werden kann.
Damit die Datei nicht für jeden Funktionsaufruf kontinuierlich eingelesen werden muss, muss Sie vom Programmierer einmal zum Start des Programms als cstring eingelesen werden.
Anschließend muss dieser cstring für jeden Aufruf einer Funktion der Bibliothek als Parameter angegeben werden.
Die Methode \texttt{get\_file\_content} kann, unter der Angabe des Dateipfades der \texttt{protocol.json}-Datei, aufgerufen werden um den Dateiinhalt einzulesen.
Zurückgegeben wird der Inhalt als cstring.
Diese Lösung verringert die Anzahl der Lesevorgänge und die damit verbundenen durch IO verursachten Latenzen.
Der Inhalt ist ab dem Einlesezeitpunkt auf dem Heap des Arbeitsspeichers gespeichert.
Der Programmierer muss diesen am Ende seines Programms durch den Aufruf der \texttt{free}-Funktion wieder freigeben.

\chapter{Verwendung der Lösung}
In disem Kapitel wird die Verwendung des Frameworks anhand dem Beispiel \textit{Alarmanlage} vorgestellt.
Gezeigt wird, wie die Aufgabe in der Programmierumgebung gelöst wurde und wie sich die Aufgabe auf dem Smartphone äußert.
In der Programmierumgebung wird dabei die Python-Bibliothek verwendet.

Damit Nachrichten ausgetauscht werden können muss zuerst das Kontrollprogramm gestartet werden.
Es wird mit dem Befehl \texttt{python ./server.py} in einer lokalen Shell gestartet.
Der Vorgang wird in Abbildung \ref{fig:start_controll_app} dargestellt.
Es handelt sich um das Python-Skript \textit{server.py}.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=.8\textwidth]{images/server_logging}
  \caption{Start der Kontrollanwendung}
  \label{fig:start_controll_app}
\end{figure}
Die Anwendung meldet, dass Sie sich erfolgreich mit dem MQTT-Broker verbunden und das korrekte Topic abboniert hat.
Die Kontrollanwendung loggt neben diesen Informationen auch rpc-requests und responses.
Sensor-requests und responses werden wegen ihrer hohen Anzahl nicht geloggt.

Die Implementierung der Lösung der Aufgabe ist in Listing \ref{lis:alarm} vorgestellt.

\lstset{language=python, captionpos=b, frame=single, numberstyle=\tiny, style=customcs}
\lstinputlisting[label=lis:alarm, caption=Alarmanlage-Beispiel]{listings/code_examples/alarm.py}
Die Bibliothek wird in Zeile 2 importiert.
Dafür muss die Datei \texttt{smartbit.py} im gleichen Ordner wie das Programm gespeichert sein.
In Zeile 4 wird ein Phone-Objekt erstellt, über das Sensor-Auslesemethoden wie \texttt{get\_x\_accel()} oder Smartphone-Ausgaben wie \texttt{vibrate()} augerufen werden können.
Da das Programm nie abbrechen soll, außer wenn es in der shell gestoppt wird, wird in einer While-True Schleife der Näherungssensor immer wieder abgefragt.
Anschließend wird eine halbe Sekunde gewartet um den Server nicht mit Anfragen zu überlasten.
Ist der abgerfragte Näherungssensorwert wie in der achten Zeile überprüft wird 0.0, dann liegt eine Näherung vor.
Auf dem Smartphone wird dann mit der  Methode \texttt{write\_text()} der Text ALARM usgegeben.
Das Smartphone vibriert 5 mal hintereinander im Abstand von 200 ms für eine Sekunde und lässt die Signal-LED blinken.
Insgesamt werden die RPC-Funktionen vibrate, toggle\_button und write\_text aufgerufen.
Keine dieser Funktionen liefert einen Rückgabewert.

Die Bibliothek sendet die Nachrichten an das Smartphone.
Nähert sich eine Person dem Smartphone wird der Code in der If-Bedingung ausgeführt.
Die jeweiligen Nachrichten werden als rpc\_request per UDP an die Kontrollanwendung gesendet.
Dort werden Sie angenommen, geloggt und per MQTT an das Smartphone weitergereicht.
Eine Übersicht der gesendeten Nachrichten ist in Abbildung \ref{fig:req_controll_app} zu sehen.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/server_requests}
  \caption{Nachrichtenversand der Kontrollanwendung}
  \label{fig:req_controll_app}
\end{figure}
Die Nachrichten werden im JSON Format übertragen.
rpc\_requests haben ein Typ-Feld, ein Kommando und einen Paramterwert für das Kommando.
Write\_text ist für Textausgaben auf dem Smartphone, vibrate um das Smartphone vibrieren zu lassen und led\_toggle um die LED anzusprechen.
Für write\_text wird der gibt der Parameter-Wert den anzuzeigenden Text an.
Vibrate erwartet für value die Zeitdauer der vibrierung in ms.
led\_toggle erwartet keinen Parameterwert, da der gesamte Aufruf lediglich die Farbe der LED wechselt.
Es ist nicht vorgesehen, dass die Farbe manuell gesetzt werden kann.

Auf dem Smartphone ist die App zu Anfang im Initialmodus.
Dieser ist in Abbildung \ref{fig:initial_app} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[height=0.4\textheight]{images/app_initial}
  \caption{Initialzustand der Anwendung}
  \label{fig:initial_app}
\end{figure}
Zu sehen sind zwei Buttons, beschriftet mit A und B.
Das textfeld liegt in der Mitte und zeigt zum Start den Text \textit{output} an.
Daneben gibt es noch eine Vorgangs-LED die ausgegraut oben rechts über der Signal-LED liegt.
Sie leuchtet, wenn gerade ein Vorgang wie das Ausführen einer Vibration auf dem Smartphone ausgeführt wird.

Nähert man sich dem Smartphone geht es über in den Alarmzustand der in Abbildung \ref{fig:app_alarm} dargestellt ist.
\begin{figure}[htbp]
  \centering
  \includegraphics[height=0.4\textheight]{images/app_alarm}
  \caption{Initialzustand der Anwendung}
  \label{fig:app_alarm}
\end{figure}
Erkennbar ist, dass das Textfeld den Wert \textit{ALARM} darstellt.
Die Farbe der LED hat sich von grün auf rot und wieder auf grün geändert.
Das ist erkennbar an der kleinen Screenshot-Vorschau links unten die unmittelbar vor dem in der Abbildung zu sehenden Screenshot zu sehen ist.
Die Vorgangs-LED leuchtet tief rot um zu signalisieren dass gerade eine Ausgabe ausgeführt wird.
Nicht sichtbar ist das haptische vibrationsfeedback.
Hierfür dient jedoch die Vorgangs-LED.
Sie ist auch hilfreich um bei Smartphones mit sanften Vibrationsausgaben eine Ausgabe zu erkennen.

Die Reaktionszeit liegt unter einer Sekunde.
Die Ausgabe erscheint als direkter Grund der Annäherung.


\chapter{Evaluation}\label{chap:eval}
In diesem Kapitel wird überprüft, ob die implementierte Lösung die Anforderungen erfüllt.
Überprüft wird die qualitive Nutzbarkeit der Lösung anhand der spezifizierten Anforderungen.
Für verschiedene Nutzungszenarien wie der Labor- oder Heimarbeit werden Latenzuverhalten gemessen.



Transportwege müssen berücksichtigt werden.
Die Zeiten werden in drei verschiedenen Umgebungen überprüft: In nächster Nähe zum MQTT-Server, in mittlerer Nähe und in einer virtuellen Umgebung über ein simuliertes NAT-Netzwerk.

Damit die Benutzbarkeit sichergestellt ist, müssen Latenzzeiten zwischen Smartphone und Programmierumgebung in einem akzeptablen Rahmen liegen.
Um dies herauszufinden werden die Latenzzeiten gemessen.
In diesem Kapitel wird die Latenzzeit von drei Standorten aus gemessen.

Der erste Einsatzort ist im gleichen Netzbereich wie der MQTT-Broker wodurch die Transferstrecke reduziert wird.
Neben der Latenzzeit zum Broker ist jedoch auch die Anzahl der angemeldeten Geräte am gleichen AccessPoint interessant.
Da die Geräte in direktem Wettbewerb um Sendezeit stehen bedeuten mehr Geräte an einem AccessPoint größere Latenzen.
In den Messungen werden nur WLAN-Verbindungen nach dem Standard WLAN 802.11n berücksichtigt.
Es sind dabei stets beide Geräte, Lokaler PC und Smartphone per WLAN mit dem Internet verbunden.
Untersucht wird lediglich die Zeitspanne zwischen rpc\_request und rpc\_response.
Sensor\_requests kommunizieren stets per loopback-interface mit der Kontrollanwendung.
Daher die Latenzzeiten gering.
Im Durchschnitt belaufen Sie sich auf unter 1ms.
Die Messungen sind  für den Fall interessant, für den Studierende an der Hochschule die Lösung nutzen möchten.
Zum Beispiel in Laboren.

Der zweite Einsatzort ist ein Heimnetz, das etwa 8 Hops entfernt vom MQTT-Broker liegt.
Etwa 8 Geräte sind dabei auf dem Access Point angemeldet.
Die Messergebnisse sind relevant für die Heimarbeit oder das Erledigen von Hausaufgaben.
Die Ergebnisse sind in Abbildung \ref{fig:measure_home} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{images/timing_at_home}
  \caption{Zeitmessungen im Heimnetz}
  \label{fig:measure_home}
\end{figure}
Insgesamt wurden 100 Messungen durchgeführt.
Im Mittel beträgt die Reaktionszeit 537 ms.
Die Streuung ist bei einer Standardabweichung von 238ms allerdings auch sehr breit gestreut.
Alle Messungen blieben jedoch unter 1s Reaktionszeit.

Der letzte Einsatzort ist in einer virtuellen Maschine auf dem lokalen PC das über den virtuellen Netzwerkkontroller aus einem NAT-Netzbereich auf das Internet zugreift.
Das Smartphone befindet sich direkt im Netzbereich des lokalen PCs.
Die gemessenen Daten sind in Abbildung \ref{fig:measure_vm} dargestellt.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{images/timing_vm}
  \caption{Zeitmessungen in der virtuellen Maschine}
  \label{fig:measure_vm}
\end{figure}
Wieder wurden 100 Messungen vorgenommen.
Im Mittel beträgt die Reaktionszeit nun 3255 ms.
Die Streuung ist mit einer Standardabweichung von 845 ms relativ gleichgroß.
Die Reaktionszeit ist also im Durchschnitt sehr hoch, etwa sechs mal langsamer als bei einer Verwendung der Programmierumgebung auf dem Hostsystem.
Eine direkte Assoziation zwischen Eingabe und Ausgabe kann nicht garantiert werden.

Latenzprobleme per MQTT treten nicht auf.
Trotz einem QOS-Level 0 werden auch Ausgabeanfragen sicher übertragen und ausgeführt.
Da die Nachrichten über TLS übertragen werden ist der Austausch sicher.
Logging-Möglichkeiten in der Kontrollanwendung und der Android-App erleichterten die Entwicklung sehr und halfen bei der Fehlersuche.

\chapter{Fazit}\label{chap:fazit}
Die implementierte Lösung erfüllt die Anforderungen zufriedenstellend.
Die im Vorfeld durchgeführte Konzeption der Lösung ermöglichte eine problemlose Implementierung.
Während der Entwicklung wurden jedoch einige Designentscheidungen getroffen, welche die Lösung beschränken.
Sensordaten werden von der Kontrollanwendung nicht für einzelne Geräte eingespeichert.
Es ist nicht möglich Programmcode simultan auf mehreren Smartphones gleichzeitig auszuführen.
Gruppen-Sessions können nicht erstellt werden.
Für Programme die die Java und Python-Schnittstelle könnte dies unintuitiv erscheinen.
Die Bedeutung eines Phone-Objektes lässt auf eine zwischen Einzelgeräten unterscheidende Verwendung schließen.
Ein weiterer Nachteil der Benutzerfreundlichkeit besteht in der zwingenden Verwendung von Hilfs-Bibliotheken für den Nachrichtenaustausch über JSON.
Sowohl für Java, als auch für C sind zusätzliche JSON-Parser für die Kommunikation zwischen Bibliothek und Kontrollanwendung nötig.
Für eine erfolgreiche Kompilierung in C muss der Dateipfad für diesen dem Linker bekannt gemacht werden.
Für die interne Struktur ist die Datenverwaltung innerhalb des Programms ausreichend.
Durch den asynchronen Ansatz des Multithreading können beide Kommunikationspartner gleichzeitig über das Kontrollprogramm kommunizieren und zwischengespeicherte Daten auslesen oder bearbeiten.
Die Möglichkeit mehrere Werte zum internen Datenspeicher hinzuzufügen wird jedoch nicht unterstützt.
Häufige Sensor-Anfragen werden mit dem gleichen, einzeln zwischengespeicherten Sensorwert beantwortet, welcher zusätzlich kein Ablaufdatum besitzt.
Abbrüche der Übertragung resultieren in der kontinuierlichen Übermittlung des zuletzt eingespeicherten Sensorwerts.

Zur Ablösung von Hilfsbibliotheken eignet sich die Verwendung eines Binärprotokolls.
In Enumerationen konvertierte Nachrichtenformate und Parameter könnten statt der implementierten Darstellung mit JSON eingesetzt werden.
Dadurch entfiehle nicht nur der Nachteil der unintuitiven Einbindung.
Die Nachrichtengröße würde ebenfalls verringert werden.
Energieeffizienz der Android-App wurde zum Vorteil der Latenzreduzierung während der Implementierung nicht wesentlich berücksichtigt.
Zum Start der Anwendung werden die Sensormessprozesse unmittelbar gestartet und Sensorwerte an die Kontrollanwendung gesendet, was einen erhöhten Energieverbrauch bedeutet.
Sollten sich die Startzeiten der Sensormessprozesse nicht wesentlich auf die Latenzen auswirken, wäre eine auf Anfragen basierende Sensmessdatenübertragung erwägenswert um den Energieverbrauch zu reduzieren.

% Listen wenn überhaupt ans Ende und nicht an den Anfang.
% Meist ist das aber unnötig.
% \listoffigures % Liste der Abbildungen 
% \listoftables % Liste der Tabellen
\newpage

\bibliographystyle{plain} % Literaturverzeichnis
\begin{btSect}{thesis} % mit bibtopic Quellen trennen
\addcontentsline{toc}{chapter}{Literaturverzeichnis und Online-Quellen}
\section*{Literaturverzeichnis}
\btPrintCited
\end{btSect}
\begin{btSect}{online}
\section*{Online-Quellen}
\btPrintCited
%\bibliography{online}
\end{btSect}
% dann mit "bibtex thesis1" und "bibtex thesis2" arbeiten

\end{document}
;;; Local Variables:
;;; ispell-local-dictionary: "de_DE-neu"
;;; End:


