# Todos

## Arbeit
### Gliederung ausschreiben
### wichtige Passen schonmal rausschreiben
### verbesserungen an bestehendem Text implementieren

## Binäres Protokoll entwickeln

## C-Library schreiben

## Test mit und ohne QOS2 mit IOT WLAN

## Timeout in Queue


# Aufgekommene Fragen

## JSON unter C?
Protokoll muss einmalig zwischen allen Programmiersprachen standardisiert werden.
Zuerst war die Idee Nachrichten in zwei Systeme aufzuteilen:

1. Binärprotokoll
2. JSON-Basiertes Protokoll

Das Problem ist, dass das Binärprotokoll zwischen Library und Mittelware zum Einsatz kommt.
Dafür sollten pro Typ, Argument und Command ein ENUM zum Einsatz kommen der die Entitäten durchnumeriert.
Die Nummern sollten am Ende entweder als Char oder zusammengesetzt als int übertragen werden.
In der Middleware hätten Sie dann wieder aufgeschlüsselt und in JSON umgewandelt werden müssen.
![BinaryProtocol](images/binary_protocol.png)


Die Library soll aber Programmiersprachenunabhänig sein.
Das bedeutet, dass die Enums in jeder Sprache in exakt der gleichen Reihenfolge definiert sein müssen damit es nicht zu fehlern kommt.

Gerade bei Commands kommen jedoch ständig neue hinzu. Diese müssten auf allen anderen Implementierungen auch aktuell gehalten werden.

### Lösung

Die Lösung hierfür ist doch alles per JSON zu machen.
Es wurde sich ursprünglich nur gegen JSON in der Library entschieden, da für C dann extra ein Parser geschrieben werden musste.
JSON ist bei Java und Python nämlich bereits dabei.

Nun soll auf die Lib [cJSON](https://github.com/DaveGamble/cJSON) zurückgegriffen werden.
![Templates](images/all_json.png) Die JSON-Templates sollen dann aus einer Datei ausgelesen werden.
Diese gilt sowohl für die Libraries (C, Python, Java) und Android.

# Abgeleitete Todos

## Big Fuckup Protokoll
- [ ] Protokolle einzeln für zwischen den Endgeräten definieren
- [ ] Nicht auf Anfrage ganze Protokolle rumschicken für alle Nachrichtentypen die's gibt. Generalisierung ok aber so is der einzige Vorteile halt zum Fenster rausgeworfen.

## ServerIntern
- [ ] ZWEI Queues für MQTT work und sensor-request-udp work. Sonst ist:
    1. Der Locking Vorteil für'n Arsch weil nur ein Thread drauf zugreift. Kannste gleich sleepen.
    2. Ganze Schmutz von wegen Queue zubomben gelöst weil egal gibt zwei queues selber schuld wenn lib zu oft fragt.

## Libs
- [ ] Impmplementation in Java, C und Python. Python schon halbwegs done. Am Besten zuerst mit der Smartphone-GUI anfangen, dann daraus Calls ableiten.
- [ ] EIN Szenario/Aufgabe soll in allen drei Libs funktionieren.

## GUIS
- [ ] GUI schreiben Smartphone
- [ ] GUI schreiben Server 


## Zu klären
- [ ] Wie geht Sensorübertragung Sinnvoll? Ganz sicher nicht indem man alles in eine Root-Activity klatscht.
- [ ] Wie gehen UDP Bindings in C? Wie drauf reagieren? Warten Auf Return Werte mit Throtteling um überladung zu verhindern?
- [ ] QOS-Level nochmal checken wenn auf 2 mit IOT Wifi besser?

## Arbeit

- [ ] Sensor Hintergrundgeschichte raus braucht kein Mensch
- [ ] Sections tauchen nciht im Inhaltsverzeichnis auf ist das gewollt?
- [ ] Gliederung fertig machen
- Auf Textmasse gehen. Viel schreiben.

### Einleitung
- Deutlich mehr was machen wir kein yadayada
- Wenn Gliederung stimmt, dann auch schonmal gerne vorwärtsverweisen wo was steht. Gibt viel Text

### Aufgabenstellung
- Aufgaben erweitern NACH der Demo
- API immer noch vollständig raus bzw. erst die Anforderungen. API ganz hinten hin.

### Architektur
- Wenn QOS2 nicht funktioniert raus. Scheiß drauf dann ist's halt ein QOS ein Topic fertig. Kann man dann auch überlegen mit mehreren Smarthones.
- Kommandos einmal ganz dumm runterschreiben.
- Sensoren komplett raus oder kurz halten in allgemein und dann citen
- UDP fertig schreiben
- Wie funktioniert die Middleware intern? Und die App? Fehlt komplett!

## Evaluation
- Neues Kapitel in der die Experimente ausprobiert werden. Hier kommen Screenshots und Erklärungen rein.

## Fazit
- Schonmal dran rütteln. Kurze zusammenfassung. Ausblick schonmal. Rest abhängig von der Evalutation